local obf_cached_str = {};
local obf_stringchar = string.char;
local obf_stringbyte = string.byte;
local obf_stringsub = string.sub;
local obf_bitlib = bit32 or bit;
local obf_XOR = obf_bitlib.bxor;
local obf_tableconcat = table.concat;
local obf_tableinsert = table.insert;
local function LUAOBFUSACTOR_DECRYPT_STR_0(LUAOBFUSACTOR_STR, LUAOBFUSACTOR_KEY)
	local result = {};
	for i = 1, #LUAOBFUSACTOR_STR do
		obf_tableinsert(result, obf_stringchar(obf_XOR(obf_stringbyte(obf_stringsub(LUAOBFUSACTOR_STR, i, i + 1)), obf_stringbyte(obf_stringsub(LUAOBFUSACTOR_KEY, 1 + (i % #LUAOBFUSACTOR_KEY), 1 + (i % #LUAOBFUSACTOR_KEY) + 1))) % 256));
	end
	return obf_tableconcat(result);
end
obf_cached_str[1559 - (166 + 554)] = LUAOBFUSACTOR_DECRYPT_STR_0("\27\143\143\52\105\93\17\143\144\48\105", "\57\116\237\229\87\71");
obf_cached_str[397 + 441] = LUAOBFUSACTOR_DECRYPT_STR_0("\18\65\111\15\97\148\103\68", "\66\55\108\94\63\18\180");
obf_cached_str[2294 - 1457] = LUAOBFUSACTOR_DECRYPT_STR_0("\143\223\55\243\129", "\102\235\186\85\134\230\115\80");
obf_cached_str[2005 - 1169] = LUAOBFUSACTOR_DECRYPT_STR_0("\17\226\127\201\164", "\182\126\128\21\170\138\235\121");
obf_cached_str[277 + 558] = LUAOBFUSACTOR_DECRYPT_STR_0("\17\75\214\230\182\240\193\71", "\228\52\102\231\214\197\208");
obf_cached_str[3489 - 2655] = LUAOBFUSACTOR_DECRYPT_STR_0("\39\124\226\223\18\89\71\23\66\231", "\43\120\35\131\170\102\54");
obf_cached_str[1333 - 500] = LUAOBFUSACTOR_DECRYPT_STR_0("\61\127\228\253\6\69\245", "\147\98\32\141");
obf_cached_str[2526 - 1694] = LUAOBFUSACTOR_DECRYPT_STR_0("\95\251\12\188\96\123\240\105\64\248\18\188\87", "\26\48\153\102\223\63\31\153");
obf_cached_str[2099 - (1249 + 19)] = LUAOBFUSACTOR_DECRYPT_STR_0("\251\233\161\169\9\42\252\232", "\94\159\128\210\217\104");
obf_cached_str[750 + 80] = LUAOBFUSACTOR_DECRYPT_STR_0("\67\56\233\173\54\69\52\240\190\12\79\46", "\105\44\90\131\206");
obf_cached_str[3226 - 2397] = LUAOBFUSACTOR_DECRYPT_STR_0("\220\197\229\191\166\245\104", "\223\181\171\150\207\195\150\28");
obf_cached_str[1849 - (686 + 400)] = LUAOBFUSACTOR_DECRYPT_STR_0("\14\177", "\130\124\155\106");
obf_cached_str[588 + 161] = LUAOBFUSACTOR_DECRYPT_STR_0("\69\10\180\164\22\122\76\17", "\19\35\127\218\199\98");
obf_cached_str[974 - (73 + 156)] = LUAOBFUSACTOR_DECRYPT_STR_0("\49\54\40\220\5", "\227\88\82\115");
obf_cached_str[4 + 739] = LUAOBFUSACTOR_DECRYPT_STR_0("\131\27\34\249\225", "\188\234\127\121\198");
obf_cached_str[1547 - (721 + 90)] = LUAOBFUSACTOR_DECRYPT_STR_0("\247\48\67\236\205\248\42\67", "\185\145\69\45\143");
obf_cached_str[9 + 719] = LUAOBFUSACTOR_DECRYPT_STR_0("\12\127\33\71\174", "\203\120\30\67\43");
obf_cached_str[2353 - 1628] = LUAOBFUSACTOR_DECRYPT_STR_0("\144\67\194\28\83\56", "\95\227\55\176\117\61");
obf_cached_str[1192 - (224 + 246)] = LUAOBFUSACTOR_DECRYPT_STR_0("\60\246\133\63\76\72", "\58\82\131\232\93\41");
obf_cached_str[1166 - 446] = LUAOBFUSACTOR_DECRYPT_STR_0("\251\219\5\160\181", "\200\153\183\106\195\222\178\52");
obf_cached_str[1290 - 589] = LUAOBFUSACTOR_DECRYPT_STR_0("\15\85\56\61\46", "\152\109\57\87\94\69");
obf_cached_str[127 + 569] = LUAOBFUSACTOR_DECRYPT_STR_0("\72\187\19\214\74", "\195\42\215\124\181\33\236");
obf_cached_str[17 + 676] = LUAOBFUSACTOR_DECRYPT_STR_0("\208\187\41\21\210\180\42", "\103\179\217\79");
obf_cached_str[509 + 183] = LUAOBFUSACTOR_DECRYPT_STR_0("\238\148", "\180\176\226\217\147\99\131");
obf_cached_str[1367 - 679] = LUAOBFUSACTOR_DECRYPT_STR_0("\85\223\225\224\114\232", "\143\38\171\147\137\28");
obf_cached_str[2282 - 1596] = LUAOBFUSACTOR_DECRYPT_STR_0("\34\34\54\175\238\53\46\26\183\228\42\59\32\173\222\50", "\129\70\75\69\223");
obf_cached_str[1197 - (203 + 310)] = LUAOBFUSACTOR_DECRYPT_STR_0("\224\74\166\175\34\189\230\73\166\179\15\138\247", "\213\131\37\214\214\125");
obf_cached_str[2675 - (1238 + 755)] = LUAOBFUSACTOR_DECRYPT_STR_0("\172\34\47\150\179\224\163\189\58\50\128\187\203\239\182\34\56\145\177\248", "\131\223\86\93\227\208\148");
obf_cached_str[48 + 632] = LUAOBFUSACTOR_DECRYPT_STR_0("\93\204\29\233\101", "\200\43\163\116\141\79");
obf_cached_str[2210 - (709 + 825)] = LUAOBFUSACTOR_DECRYPT_STR_0("\51\205\243\141\102\5\252\249\141\105", "\17\108\146\157\232");
obf_cached_str[1243 - 568] = LUAOBFUSACTOR_DECRYPT_STR_0("\71\181\199\77\171\87\37", "\49\24\234\174\35\207\50\93");
obf_cached_str[981 - 307] = LUAOBFUSACTOR_DECRYPT_STR_0("\33\143\18\7\11\252\12\185\8\15", "\136\126\208\102\104\120");
obf_cached_str[1537 - (196 + 668)] = LUAOBFUSACTOR_DECRYPT_STR_0("\226\247\34\54\167\229\163\63\33\174\242\220\63\33\174\244\224\36", "\196\145\131\80\67");
obf_cached_str[2649 - 1978] = LUAOBFUSACTOR_DECRYPT_STR_0("\243\13\47\45\92\19\104\217\16", "\26\134\100\65\89\44\103");
obf_cached_str[1387 - 717] = LUAOBFUSACTOR_DECRYPT_STR_0("\113\254\253\100\125\163\171\106\117\163", "\90\77\219\142");
obf_cached_str[1502 - (171 + 662)] = LUAOBFUSACTOR_DECRYPT_STR_0("\27\255\252", "\38\117\150\144\121\107");
obf_cached_str[761 - (4 + 89)] = LUAOBFUSACTOR_DECRYPT_STR_0("\200\232", "\93\237\144\229\143");
obf_cached_str[2337 - 1670] = LUAOBFUSACTOR_DECRYPT_STR_0("\22\19\49\35\98\75", "\90\51\107\20\19");
obf_cached_str[243 + 423] = LUAOBFUSACTOR_DECRYPT_STR_0("\159\126\254\72\184\102\219\126\254\76", "\86\163\91\141\114\152");
obf_cached_str[2916 - 2252] = LUAOBFUSACTOR_DECRYPT_STR_0("\16\128\30\0\196\91\77\58\157", "\63\101\233\112\116\180\47");
obf_cached_str[260 + 403] = LUAOBFUSACTOR_DECRYPT_STR_0("\1\166\162", "\177\111\207\206\115\159\136\140");
obf_cached_str[2146 - (35 + 1451)] = LUAOBFUSACTOR_DECRYPT_STR_0("\35\203\209\163\234\156\3\49\54\208\133\175\233\136\18\105\98\222\133\136\210\160\59\49\45\221\207\163\228\152", "\17\66\191\165\198\135\236\119");
obf_cached_str[2112 - (28 + 1425)] = LUAOBFUSACTOR_DECRYPT_STR_0("\137\181\253\199\121\152\181\169\214\123\200\168\231\198\113\144\225\232\130\90\189\141\197\130\123\138\171\236\193\96", "\20\232\193\137\162");
obf_cached_str[2651 - (941 + 1052)] = LUAOBFUSACTOR_DECRYPT_STR_0("\69\131\60\113\145\60\117\143\127\164", "\235\26\220\82\20\230\85\27");
obf_cached_str[630 + 27] = LUAOBFUSACTOR_DECRYPT_STR_0("\193\156\192\121\80\251\187", "\52\158\195\169\23");
obf_cached_str[2170 - (822 + 692)] = LUAOBFUSACTOR_DECRYPT_STR_0("\138\0\243\41\71\148\16\188\49\224", "\98\213\95\135\70\52\224");
obf_cached_str[934 - 279] = LUAOBFUSACTOR_DECRYPT_STR_0("\196\204\85\42\212\204\7\48\213\210\68\0\212\212\70\44\196", "\95\183\184\39");
obf_cached_str[308 + 345] = LUAOBFUSACTOR_DECRYPT_STR_0("\249\59\42\45\216\85\22\4\236\32\126\33\219\65\7\92\184\46\126\6\224\105\46\4\251\35\63\59\198", "\36\152\79\94\72\181\37\98");
obf_cached_str[949 - (45 + 252)] = LUAOBFUSACTOR_DECRYPT_STR_0("\184\167\179\26\133\227\228\249\167\168\95\129\253\244\188\171\231\30\200\221\197\149\159\231\28\132\242\227\170", "\144\217\211\199\127\232\147");
obf_cached_str[644 + 6] = LUAOBFUSACTOR_DECRYPT_STR_0("\19\140\234\177\14\141\169\173\5\133\236\189\20\134\251\254\1\133\251\187\1\141\240\254\9\132\249\178\5\132\236\176\20\140\237", "\222\96\233\137");
obf_cached_str[224 + 425] = LUAOBFUSACTOR_DECRYPT_STR_0("\233\14\50\229\250\201\229\13\54\232\235\205\239\13\98\251\250\213\245\10\48\236\251\132\230\12\48\169\236\211\233\25\56\229\246\202\231\67\53\224\235\204\160\13\39\254\191\215\229\15\39\234\235\203\242", "\164\128\99\66\137\159");
obf_cached_str[1576 - 928] = LUAOBFUSACTOR_DECRYPT_STR_0("\188\183\26\37\248\222\224\191\189\26\109\241\213\181\191\182\84\109\178\201", "\192\209\210\110\77\151\186");
obf_cached_str[1080 - (114 + 319)] = LUAOBFUSACTOR_DECRYPT_STR_0("\188\44\66\164\188\59\88\169\167\127\93\224\185\119\93\224\185\114\70\164\188\59\81", "\132\153\95\120");
obf_cached_str[926 - 280] = LUAOBFUSACTOR_DECRYPT_STR_0("\200\218\165\132\220\207\209\183", "\179\186\191\195\231");
obf_cached_str[821 - 180] = LUAOBFUSACTOR_DECRYPT_STR_0("\131\152\101\66\247\71\69\102\253\206", "\70\216\189\22\98\210\52\24");
obf_cached_str[407 + 230] = LUAOBFUSACTOR_DECRYPT_STR_0("\171\203\196\62\70\183", "\47\217\174\176\95");
obf_cached_str[947 - 311] = LUAOBFUSACTOR_DECRYPT_STR_0("\44\249\63\213\26\217\142\40\237\56\223", "\226\77\140\75\186\104\188");
obf_cached_str[1330 - 695] = LUAOBFUSACTOR_DECRYPT_STR_0("\250\40\165\74\115\175\196", "\216\136\77\201\47\18\220\161");
obf_cached_str[2597 - (556 + 1407)] = LUAOBFUSACTOR_DECRYPT_STR_0("\127\253\208\162\9\79\124\81\231\212\186", "\25\18\136\164\195\107\35");
obf_cached_str[1839 - (741 + 465)] = LUAOBFUSACTOR_DECRYPT_STR_0("\45\68\46\204", "\156\78\43\94\181\49\113");
obf_cached_str[1097 - (170 + 295)] = LUAOBFUSACTOR_DECRYPT_STR_0("\173\163\216", "\203\195\198\175\170\93\71\237");
obf_cached_str[333 + 298] = LUAOBFUSACTOR_DECRYPT_STR_0("\9\48\22\79\7", "\157\104\92\122\32\100\109");
obf_cached_str[579 + 51] = LUAOBFUSACTOR_DECRYPT_STR_0("\196\112\61\162\238\130", "\118\182\21\73\195\135\236\204");
obf_cached_str[1548 - 919] = LUAOBFUSACTOR_DECRYPT_STR_0("\161\86\17\225\178\70\9\235\161\80\0", "\142\192\35\101");
obf_cached_str[521 + 107] = LUAOBFUSACTOR_DECRYPT_STR_0("\74\192\91\255\66\32\242", "\151\56\165\55\154\35\83");
obf_cached_str[402 + 224] = LUAOBFUSACTOR_DECRYPT_STR_0("\225\171\253\145\15\203\235\177\253\130\81\208\224\186", "\185\142\221\152\227\34");
obf_cached_str[354 + 271] = LUAOBFUSACTOR_DECRYPT_STR_0("\175\226\48\176\198\80", "\60\221\135\68\198\167");
obf_cached_str[1854 - (957 + 273)] = LUAOBFUSACTOR_DECRYPT_STR_0("\228\175\80\57\193\48\224\165\23\53\215\36\224\190\67\53\203", "\84\133\221\55\80\175");
obf_cached_str[167 + 455] = LUAOBFUSACTOR_DECRYPT_STR_0("\183\231\83\131\133\20", "\48\236\184\118\185\216");
obf_cached_str[247 + 368] = LUAOBFUSACTOR_DECRYPT_STR_0("\243\81\251\70\86\110", "\26\156\55\157\53\51");
obf_cached_str[2339 - 1725] = LUAOBFUSACTOR_DECRYPT_STR_0("\45\151", "\186\78\227\112\38\73");
obf_cached_str[1615 - 1002] = LUAOBFUSACTOR_DECRYPT_STR_0("\42\184\41\40\44", "\88\73\204\80");
obf_cached_str[1868 - 1256] = LUAOBFUSACTOR_DECRYPT_STR_0("\47\201\218\3\48", "\85\92\189\163\115");
obf_cached_str[3025 - 2414] = LUAOBFUSACTOR_DECRYPT_STR_0("\80\192\166\35", "\175\62\161\203\70");
obf_cached_str[2390 - (389 + 1391)] = LUAOBFUSACTOR_DECRYPT_STR_0("\19\70\237\86\40\124\252", "\56\76\25\132");
obf_cached_str[383 + 226] = LUAOBFUSACTOR_DECRYPT_STR_0("\21\23\181\76\101\62\58\168\77\113", "\22\74\72\193\35");
obf_cached_str[64 + 544] = LUAOBFUSACTOR_DECRYPT_STR_0("\249\161\54\246\67\43\170\186\38\233\67\0\227\163\37\241", "\95\138\213\68\131\32");
obf_cached_str[1379 - 773] = LUAOBFUSACTOR_DECRYPT_STR_0("\95\81\134\246\18\103\156\168", "\130\42\56\232");
obf_cached_str[1554 - (783 + 168)] = LUAOBFUSACTOR_DECRYPT_STR_0("\183\141\213\40", "\85\212\233\176\78\92\205");
obf_cached_str[2020 - 1418] = LUAOBFUSACTOR_DECRYPT_STR_0("\186\108\187\65\193\31\195\31\219", "\58\228\55\158");
obf_cached_str[590 + 9] = LUAOBFUSACTOR_DECRYPT_STR_0("\47\157\191\160\24\28\62\148\155\147\124\91\95\236\228", "\115\113\198\205\206\86");
obf_cached_str[901 - (309 + 2)] = LUAOBFUSACTOR_DECRYPT_STR_0("\243\66\241\232", "\23\154\44\130\156");
obf_cached_str[1808 - 1219] = LUAOBFUSACTOR_DECRYPT_STR_0("\174\38\82\95\165", "\214\205\74\51\44");
obf_cached_str[1800 - (1090 + 122)] = LUAOBFUSACTOR_DECRYPT_STR_0("\250\198\60\190\11\158\55\250\195\52\167\15\221\100\255\203\33\224\31\139\55", "\68\218\230\25\147\63\174");
obf_cached_str[191 + 396] = LUAOBFUSACTOR_DECRYPT_STR_0("\45\84\88\181\198\191\42\35\84", "\66\76\48\60\216\163\203");
obf_cached_str[1961 - 1377] = LUAOBFUSACTOR_DECRYPT_STR_0("\105\133\151", "\112\32\200\199\131");
obf_cached_str[399 + 183] = LUAOBFUSACTOR_DECRYPT_STR_0("\212\11\53", "\64\157\70\101\114\105");
obf_cached_str[1698 - (628 + 490)] = LUAOBFUSACTOR_DECRYPT_STR_0("\69\1\239\62\82\27\67", "\118\38\99\137\76\51");
obf_cached_str[104 + 475] = LUAOBFUSACTOR_DECRYPT_STR_0("\176\167\240\200\200\4", "\24\195\211\130\161\166\99\16");
obf_cached_str[1430 - 852] = LUAOBFUSACTOR_DECRYPT_STR_0("\253\229\235", "\174\139\165\209\129");
obf_cached_str[2527 - 1974] = LUAOBFUSACTOR_DECRYPT_STR_0("\47\5\231\31\63\73\231\0\62\12\231\8\53\73\226\9\42\0\232\9\40\73\163\31", "\108\76\105\134");
obf_cached_str[1326 - (431 + 343)] = LUAOBFUSACTOR_DECRYPT_STR_0("\254\235\29\246\234\212\225\255\30\224\184\217\226\234\77\245\247\194\227\250\77\182\235", "\183\141\158\109\147\152");
obf_cached_str[1110 - 560] = LUAOBFUSACTOR_DECRYPT_STR_0("\231\240\255\130\234\216\252\133\230\142\210\132\227\142\210\132", "\174\207\171\161");
obf_cached_str[1582 - 1035] = LUAOBFUSACTOR_DECRYPT_STR_0("\151\77\205\203\119\146\54\155\221\122\186\53\149\200\122\186\66\155\221\122\186\66\150\186\1\236\86\227\202\118\236\86\155\146\117\237", "\95\201\104\190\225");
obf_cached_str[431 + 114] = LUAOBFUSACTOR_DECRYPT_STR_0("\26\185\47\122\7\170", "\19\105\205\93");
obf_cached_str[70 + 474] = LUAOBFUSACTOR_DECRYPT_STR_0("\94\185\163\148\78\245\172\134\80\176\226\130\69\165\167\132\73\176\166\203\29\178\173\147\29\240\177", "\231\61\213\194");
obf_cached_str[2238 - (556 + 1139)] = LUAOBFUSACTOR_DECRYPT_STR_0("\24\147\182\77\5\128", "\36\107\231\196");
obf_cached_str[556 - (6 + 9)] = LUAOBFUSACTOR_DECRYPT_STR_0("\7\91\3\90\11\77\69\31\11\85\8\76\27\21\73\80\26\25\10\83\9\74\26\31\6\88\4\90\72\92\17\79\13\90\29\90\12\21\73\88\7\77\73\26\27", "\63\104\57\105");
obf_cached_str[99 + 441] = LUAOBFUSACTOR_DECRYPT_STR_0("\38\153\105\86\220\168", "\184\85\237\27\63\178\207\212");
obf_cached_str[275 + 261] = LUAOBFUSACTOR_DECRYPT_STR_0("\135\236\76\160\247", "\96\196\128\45\211\132");
obf_cached_str[701 - (28 + 141)] = LUAOBFUSACTOR_DECRYPT_STR_0("\252\12\197\244\141\175\247\48\198\29\203\236", "\85\153\116\166\156\236\193\144");
obf_cached_str[206 + 325] = LUAOBFUSACTOR_DECRYPT_STR_0("\36\57\181", "\230\77\84\197\188\22\207\183");
obf_cached_str[654 - 124] = LUAOBFUSACTOR_DECRYPT_STR_0("\183\139\18\241\122\98\188\154\0\241\122\116", "\22\197\234\101\174\25");
obf_cached_str[375 + 154] = LUAOBFUSACTOR_DECRYPT_STR_0("\62\208\209\37\241\213\244\90\41", "\42\76\177\166\122\146\161\141");
obf_cached_str[1845 - (486 + 831)] = LUAOBFUSACTOR_DECRYPT_STR_0("\165\86\210\34\39\170\174\71\192", "\222\215\55\165\125\65");
obf_cached_str[1371 - 844] = LUAOBFUSACTOR_DECRYPT_STR_0("\120\165\66\90\211", "\182\21\209\59\42");
obf_cached_str[1851 - 1325] = LUAOBFUSACTOR_DECRYPT_STR_0("\20\67\46\166", "\110\122\34\67\195\95\41\133");
obf_cached_str[100 + 425] = LUAOBFUSACTOR_DECRYPT_STR_0("\23\234\168\198\50\78\11\253", "\58\100\143\196\163\81");
obf_cached_str[1656 - 1132] = LUAOBFUSACTOR_DECRYPT_STR_0("\3\122\213\186\254\120\21", "\109\92\37\188\212\154\29");
obf_cached_str[1786 - (668 + 595)] = LUAOBFUSACTOR_DECRYPT_STR_0("\225\155\79\67\87\200\90\215\170\92", "\40\190\196\59\44\36\188");
obf_cached_str[470 + 52] = LUAOBFUSACTOR_DECRYPT_STR_0("\46\192\168\200\116\90\103\93\63\222\185\226\122\75\51\90\50\208", "\50\93\180\218\189\23\46\71");
obf_cached_str[104 + 411] = LUAOBFUSACTOR_DECRYPT_STR_0("\130\146\52\169", "\29\235\228\85\219\142\235");
obf_cached_str[1401 - 887] = LUAOBFUSACTOR_DECRYPT_STR_0("\98\202\136\141\176\24\124\214", "\118\16\175\233\233\223");
obf_cached_str[803 - (23 + 267)] = LUAOBFUSACTOR_DECRYPT_STR_0("\242\254\53\166\32", "\69\145\138\76\214");
obf_cached_str[2456 - (1129 + 815)] = LUAOBFUSACTOR_DECRYPT_STR_0("\201\157\70\18\9", "\141\186\233\63\98\108");
obf_cached_str[898 - (371 + 16)] = LUAOBFUSACTOR_DECRYPT_STR_0("\229\243\109\21\131\206", "\188\150\150\25\97\230");
obf_cached_str[2260 - (1326 + 424)] = LUAOBFUSACTOR_DECRYPT_STR_0("\193\61\173\34\188\16", "\98\166\88\217\86\217");
obf_cached_str[963 - 454] = LUAOBFUSACTOR_DECRYPT_STR_0("\197\117\200\50", "\121\171\20\165\87\50\67");
obf_cached_str[1856 - 1348] = LUAOBFUSACTOR_DECRYPT_STR_0("\249\230\138\208\42\239\222", "\138\166\185\227\190\78");
obf_cached_str[625 - (88 + 30)] = LUAOBFUSACTOR_DECRYPT_STR_0("\251\16\53\43\28\208\61\40\42\8", "\111\164\79\65\68");
obf_cached_str[1277 - (720 + 51)] = LUAOBFUSACTOR_DECRYPT_STR_0("\71\96\20\38\77\64\56\91\118\12\48\113\68\106\91\100\3\33\90\77", "\24\52\20\102\83\46\52");
obf_cached_str[1096 - 603] = LUAOBFUSACTOR_DECRYPT_STR_0("\244\63\255\53\244\127\248\42", "\16\135\90\139");
obf_cached_str[2262 - (421 + 1355)] = LUAOBFUSACTOR_DECRYPT_STR_0("\91\226\207\20\40\146\202\97\89\229\202", "\60\115\204\230");
obf_cached_str[773 - 304] = LUAOBFUSACTOR_DECRYPT_STR_0("\33\190\40\232\59\167\45\166\36\162\44\242\59\179\44\234\116\245\48", "\134\84\208\67");
obf_cached_str[230 + 238] = LUAOBFUSACTOR_DECRYPT_STR_0("\145\197\179\132\183\131", "\228\226\177\193\237\217");
obf_cached_str[1524 - (286 + 797)] = LUAOBFUSACTOR_DECRYPT_STR_0("\60\82\215\226\19\90", "\155\99\63\163");
obf_cached_str[1608 - 1168] = LUAOBFUSACTOR_DECRYPT_STR_0("\68\53\177\83\165", "\197\27\92\223\32\209\187\17");
obf_cached_str[725 - 287] = LUAOBFUSACTOR_DECRYPT_STR_0("\247\87\11\57\17\215\171\144", "\227\168\58\110\77\121\184\207");
obf_cached_str[876 - (397 + 42)] = LUAOBFUSACTOR_DECRYPT_STR_0("\63\137\163\93\5", "\48\96\231\194");
obf_cached_str[137 + 299] = LUAOBFUSACTOR_DECRYPT_STR_0("\59\122\77\36\205\1\93", "\169\100\37\36\74");
obf_cached_str[1235 - (24 + 776)] = LUAOBFUSACTOR_DECRYPT_STR_0("\227\214\26\62\39\233", "\70\133\185\104\83");
obf_cached_str[668 - 234] = LUAOBFUSACTOR_DECRYPT_STR_0("\75\101", "\165\40\17\212\158");
obf_cached_str[1218 - (222 + 563)] = LUAOBFUSACTOR_DECRYPT_STR_0("\58\178\172\57\143", "\160\89\198\213\73\234\89\215");
obf_cached_str[951 - 519] = LUAOBFUSACTOR_DECRYPT_STR_0("\41\6\75\94\242", "\107\79\114\50\46\151\231");
obf_cached_str[311 + 120] = LUAOBFUSACTOR_DECRYPT_STR_0("\52\103\96\81\203", "\174\89\19\25\33");
obf_cached_str[620 - (23 + 167)] = LUAOBFUSACTOR_DECRYPT_STR_0("\213\67\20\123\164\175\203", "\203\184\38\96\19\203");
obf_cached_str[2227 - (690 + 1108)] = LUAOBFUSACTOR_DECRYPT_STR_0("\179\94\142\12\185\29\183\85", "\111\195\44\225\124\220");
obf_cached_str[155 + 273] = LUAOBFUSACTOR_DECRYPT_STR_0("\95\71\123\24\74\71\96\1\74\70", "\104\47\53\20");
obf_cached_str[353 + 74] = LUAOBFUSACTOR_DECRYPT_STR_0("\205\52\249\87\186\222\41\250\80", "\213\189\70\150\35");
obf_cached_str[1274 - (40 + 808)] = LUAOBFUSACTOR_DECRYPT_STR_0("\251\191\7\30", "\152\149\222\106\123\23");
obf_cached_str[70 + 355] = LUAOBFUSACTOR_DECRYPT_STR_0("\128\114\63\26\217\192", "\178\230\29\77\119\184\172");
obf_cached_str[1621 - 1197] = LUAOBFUSACTOR_DECRYPT_STR_0("\145\208\180\178\170\234\165", "\220\206\143\221");
obf_cached_str[405 + 18] = LUAOBFUSACTOR_DECRYPT_STR_0("\192\78\64\185\37\202\238\246\127\83", "\156\159\17\52\214\86\190");
obf_cached_str[224 + 198] = LUAOBFUSACTOR_DECRYPT_STR_0("\30\37\39\104\14\106\77\1\39\114\25\113\14\62\57", "\30\109\81\85\29\109");
obf_cached_str[222 + 182] = LUAOBFUSACTOR_DECRYPT_STR_0("\88\174\49\27", "\147\54\207\92\126\115\131");
obf_cached_str[974 - (47 + 524)] = LUAOBFUSACTOR_DECRYPT_STR_0("\104\103\13\208\83\93\28", "\190\55\56\100");
obf_cached_str[261 + 141] = LUAOBFUSACTOR_DECRYPT_STR_0("\212\252\244\214\82\255\209\233\215\70", "\33\139\163\128\185");
obf_cached_str[1096 - 695] = LUAOBFUSACTOR_DECRYPT_STR_0("\29\185\98\241\8\150\78\162\114\238\8\189\29\168\124\225\8\150\1\191", "\226\110\205\16\132\107");
obf_cached_str[592 - 195] = LUAOBFUSACTOR_DECRYPT_STR_0("\55\2\190\232\63\247", "\183\68\118\204\129\81\144");
obf_cached_str[891 - 500] = LUAOBFUSACTOR_DECRYPT_STR_0("\101\63\199", "\203\59\96\237\107\69\111\113");
obf_cached_str[2115 - (1165 + 561)] = LUAOBFUSACTOR_DECRYPT_STR_0("\8\118\185", "\174\86\41\147\112\19");
obf_cached_str[12 + 374] = LUAOBFUSACTOR_DECRYPT_STR_0("\138\39\178\216\200\86\161", "\210\228\72\198\161\184\51");
obf_cached_str[1192 - 807] = LUAOBFUSACTOR_DECRYPT_STR_0("\154\244", "\147\191\135\206\184");
obf_cached_str[147 + 237] = LUAOBFUSACTOR_DECRYPT_STR_0("\45\78\81\0", "\67\65\33\48\100\151\60");
obf_cached_str[858 - (341 + 138)] = LUAOBFUSACTOR_DECRYPT_STR_0("\212\151\221\46\130\190\91\192\142\156\45\136\189\20\212\138\201\45\131\233\17\193", "\52\178\229\188\67\231\201");
obf_cached_str[103 + 275] = LUAOBFUSACTOR_DECRYPT_STR_0("\187\207\74\82\69\69\41\64\235\205\68\82\3\101\8\117", "\45\203\163\43\38\35\42\91");
obf_cached_str[777 - 400] = LUAOBFUSACTOR_DECRYPT_STR_0("\22\188\68\29\210", "\110\89\200\44\120\160\130");
obf_cached_str[697 - (89 + 237)] = LUAOBFUSACTOR_DECRYPT_STR_0("\94\18\32\244\219\171\181\31\6\57", "\194\112\116\82\149\182\206");
obf_cached_str[1190 - 820] = LUAOBFUSACTOR_DECRYPT_STR_0("\160\93", "\62\133\121\53\227\127\109\79");
obf_cached_str[772 - 405] = LUAOBFUSACTOR_DECRYPT_STR_0("\199\0", "\62\226\46\63\63\208\169");
obf_cached_str[1246 - (581 + 300)] = LUAOBFUSACTOR_DECRYPT_STR_0("\253\49", "\237\216\21\130\149");
obf_cached_str[1584 - (855 + 365)] = LUAOBFUSACTOR_DECRYPT_STR_0("\182\77\47\2\131\85\29\97\252\17\34", "\22\147\99\73\112\226\56\120");
obf_cached_str[835 - 483] = LUAOBFUSACTOR_DECRYPT_STR_0("\121\249\45\9\39\165\123", "\196\28\151\73\86\83");
obf_cached_str[115 + 236] = LUAOBFUSACTOR_DECRYPT_STR_0("\16\210\118\94\23\249\99\77\4", "\44\99\166\23");
obf_cached_str[1585 - (1030 + 205)] = LUAOBFUSACTOR_DECRYPT_STR_0("\254\246\182\56", "\80\142\151\194");
obf_cached_str[327 + 21] = LUAOBFUSACTOR_DECRYPT_STR_0("\31\173\152\12\14", "\109\122\213\232");
obf_cached_str[320 + 23] = LUAOBFUSACTOR_DECRYPT_STR_0("\156\250\98\231\159\156", "\167\186\139\23\136\235");
obf_cached_str[627 - (156 + 130)] = LUAOBFUSACTOR_DECRYPT_STR_0("\152\182\208\210\103\170", "\110\190\199\165\189\19\145\61");
obf_cached_str[756 - 423] = LUAOBFUSACTOR_DECRYPT_STR_0("\8\239", "\224\34\142\57");
obf_cached_str[557 - 226] = LUAOBFUSACTOR_DECRYPT_STR_0("\146\254", "\118\224\156\226\22\80\136\214");
obf_cached_str[673 - 344] = LUAOBFUSACTOR_DECRYPT_STR_0("\85\69\198\173\247\220\83\94\196\176", "\168\38\44\161\195\150");
obf_cached_str[85 + 234] = LUAOBFUSACTOR_DECRYPT_STR_0("\149\241\16\48\163\139", "\194\231\148\100\70");
obf_cached_str[185 + 132] = LUAOBFUSACTOR_DECRYPT_STR_0("\254\173\23\210\93\224", "\60\140\200\99\164");
obf_cached_str[385 - (10 + 59)] = LUAOBFUSACTOR_DECRYPT_STR_0("\34\27\148\14\64\60", "\33\80\126\224\120");
obf_cached_str[89 + 225] = LUAOBFUSACTOR_DECRYPT_STR_0("\66\164\225\53\69\34", "\78\48\193\149\67\36");
obf_cached_str[1541 - 1228] = LUAOBFUSACTOR_DECRYPT_STR_0("\7\13\85", "\235\102\127\50\167\204\18");
obf_cached_str[1475 - (671 + 492)] = LUAOBFUSACTOR_DECRYPT_STR_0("\13\118\22\119\68\10", "\234\96\19\98\31\43\110");
obf_cached_str[247 + 63] = LUAOBFUSACTOR_DECRYPT_STR_0("\176\11\25\191", "\80\196\121\108\218\37\200\213");
obf_cached_str[1522 - (369 + 846)] = LUAOBFUSACTOR_DECRYPT_STR_0("\152\46\81\231", "\98\236\92\36\130\51");
obf_cached_str[81 + 224] = LUAOBFUSACTOR_DECRYPT_STR_0("\38\23\60\93\132\131", "\162\75\114\72\53\235\231");
obf_cached_str[260 + 44] = LUAOBFUSACTOR_DECRYPT_STR_0("\213\141\254\90\204", "\191\182\225\159\41");
obf_cached_str[2246 - (1036 + 909)] = LUAOBFUSACTOR_DECRYPT_STR_0("\231\253\77\211", "\54\147\143\56\182\69");
obf_cached_str[237 + 60] = LUAOBFUSACTOR_DECRYPT_STR_0("\85\18\51\78\87\19", "\38\56\119\71");
obf_cached_str[496 - 200] = LUAOBFUSACTOR_DECRYPT_STR_0("\79\116\82\1\33\75\123\88\49\35\84\117\64\1\48\73\118", "\83\38\26\52\110");
obf_cached_str[492 - (11 + 192)] = LUAOBFUSACTOR_DECRYPT_STR_0("\233\171\166\62\250\162", "\72\155\206\210");
obf_cached_str[146 + 142] = LUAOBFUSACTOR_DECRYPT_STR_0("\161\86\222\102\27\49", "\161\211\51\170\16\122\93\53");
obf_cached_str[462 - (135 + 40)] = LUAOBFUSACTOR_DECRYPT_STR_0("\42\3\25\251\57\10", "\141\88\102\109");
obf_cached_str[690 - 405] = LUAOBFUSACTOR_DECRYPT_STR_0("\38\35\20\214\244\56", "\149\84\70\96\160");
obf_cached_str[172 + 112] = LUAOBFUSACTOR_DECRYPT_STR_0("\215\178\10", "\163\182\192\109\79");
obf_cached_str[623 - 340] = LUAOBFUSACTOR_DECRYPT_STR_0("\88\214\251\230\56\201\81\205", "\160\62\163\149\133\76");
obf_cached_str[421 - 139] = LUAOBFUSACTOR_DECRYPT_STR_0("\173\30\150\36", "\204\217\108\227\65\98\85");
obf_cached_str[456 - (50 + 126)] = LUAOBFUSACTOR_DECRYPT_STR_0("\20\8\181\95\188\224\30\170", "\201\98\105\199\54\221\132\119");
obf_cached_str[776 - 497] = LUAOBFUSACTOR_DECRYPT_STR_0("\8\170\34\125\230\228", "\136\111\198\77\31\135");
obf_cached_str[62 + 216] = LUAOBFUSACTOR_DECRYPT_STR_0("\245\100\248\15\4\67\252\127", "\42\147\17\150\108\112");
obf_cached_str[1689 - (1233 + 180)] = LUAOBFUSACTOR_DECRYPT_STR_0("\29\248\136\82\249\52\54\21", "\89\123\141\230\49\141\93");
obf_cached_str[1244 - (522 + 447)] = LUAOBFUSACTOR_DECRYPT_STR_0("\195\119\161\16\140\192\121\242\32\197\200\107\188\0\145\199\113\188\89\197\139\109", "\229\174\30\210\99");
obf_cached_str[1695 - (107 + 1314)] = LUAOBFUSACTOR_DECRYPT_STR_0("\151\88\85\44\139\77", "\78\228\33\56");
obf_cached_str[127 + 146] = LUAOBFUSACTOR_DECRYPT_STR_0("\42\194\80\233\71\195", "\224\77\174\63\139\38\175");
obf_cached_str[819 - 550] = LUAOBFUSACTOR_DECRYPT_STR_0("\201\212\58\74\46\91", "\55\187\177\78\60\79");
obf_cached_str[114 + 154] = LUAOBFUSACTOR_DECRYPT_STR_0("\150\196\20\175\62\61", "\168\228\161\96\217\95\81");
obf_cached_str[527 - 261] = LUAOBFUSACTOR_DECRYPT_STR_0("\223\226\9\237\27\193", "\122\173\135\125\155");
obf_cached_str[1048 - 783] = LUAOBFUSACTOR_DECRYPT_STR_0("\35\4\198\162\249\220", "\221\81\97\178\212\152\176");
obf_cached_str[2174 - (716 + 1194)] = LUAOBFUSACTOR_DECRYPT_STR_0("\0\37\44\106\189\120", "\20\114\64\88\28\220");
obf_cached_str[5 + 257] = LUAOBFUSACTOR_DECRYPT_STR_0("\211\23\25\227\3\124", "\217\161\114\109\149\98\16");
obf_cached_str[28 + 233] = LUAOBFUSACTOR_DECRYPT_STR_0("\92\100\116", "\45\61\22\19\124\19\203");
obf_cached_str[763 - (74 + 429)] = LUAOBFUSACTOR_DECRYPT_STR_0("\13\68", "\153\83\50\50\150");
obf_cached_str[497 - 239] = LUAOBFUSACTOR_DECRYPT_STR_0("\158\171", "\227\222\148\99\37");
obf_cached_str[128 + 129] = LUAOBFUSACTOR_DECRYPT_STR_0("\205\216\17\200\82\245\163", "\200\164\171\115\164\61\150");
obf_cached_str[583 - 328] = LUAOBFUSACTOR_DECRYPT_STR_0("\6\239\32\49", "\22\114\157\85\84");
obf_cached_str[179 + 74] = LUAOBFUSACTOR_DECRYPT_STR_0("\224\180\166\209\172\83\95", "\57\148\205\214\180\200\54");
obf_cached_str[773 - 522] = LUAOBFUSACTOR_DECRYPT_STR_0("\181\177\227\214", "\176\214\213\134");
obf_cached_str[618 - 368] = LUAOBFUSACTOR_DECRYPT_STR_0("\174\148\184\215\190\136\174", "\178\218\237\200");
obf_cached_str[681 - (279 + 154)] = LUAOBFUSACTOR_DECRYPT_STR_0("\186\39\174\114", "\212\217\67\203\20\223\223\37");
obf_cached_str[1025 - (454 + 324)] = LUAOBFUSACTOR_DECRYPT_STR_0("\90\2\34\127", "\26\46\112\87");
obf_cached_str[193 + 52] = LUAOBFUSACTOR_DECRYPT_STR_0("\80\83\222\112\52\65\76", "\80\36\42\174\21");
obf_cached_str[260 - (12 + 5)] = LUAOBFUSACTOR_DECRYPT_STR_0("\225\45\233\79\111", "\166\130\66\135\60\27\17");
obf_cached_str[130 + 111] = LUAOBFUSACTOR_DECRYPT_STR_0("\86\198\194\190\249", "\167\115\181\226\155\138");
obf_cached_str[611 - 371] = LUAOBFUSACTOR_DECRYPT_STR_0("\54\142\115\190\48\142", "\220\81\226\28");
obf_cached_str[88 + 150] = LUAOBFUSACTOR_DECRYPT_STR_0("\91\9\207\173\35\212", "\184\60\101\160\207\66");
obf_cached_str[1329 - (277 + 816)] = LUAOBFUSACTOR_DECRYPT_STR_0("\199\143\3\243", "\56\162\225\118\158\89\142");
obf_cached_str[995 - 762] = LUAOBFUSACTOR_DECRYPT_STR_0("\33\166\158\247", "\186\85\212\235\146");
obf_cached_str[1412 - (1058 + 125)] = LUAOBFUSACTOR_DECRYPT_STR_0("\238\217\6\220\64\176", "\215\157\173\116\181\46");
obf_cached_str[43 + 183] = LUAOBFUSACTOR_DECRYPT_STR_0("\40\62\245\228\59", "\145\94\95\153");
obf_cached_str[1200 - (815 + 160)] = LUAOBFUSACTOR_DECRYPT_STR_0("\254\12\85\235\222\180\214", "\78\136\109\57\158\187\130\226");
obf_cached_str[960 - 736] = LUAOBFUSACTOR_DECRYPT_STR_0("\213\91\34\211", "\101\161\34\82\182");
obf_cached_str[529 - 306] = LUAOBFUSACTOR_DECRYPT_STR_0("\145\171\35\14\30\26", "\233\229\210\83\107\40\46");
obf_cached_str[53 + 169] = LUAOBFUSACTOR_DECRYPT_STR_0("\164\219", "\34\129\168\82\154\143\80\156");
obf_cached_str[645 - 424] = LUAOBFUSACTOR_DECRYPT_STR_0("\187\234\120\241", "\171\215\133\25\149\137");
obf_cached_str[2116 - (41 + 1857)] = LUAOBFUSACTOR_DECRYPT_STR_0("\38\222\84\73\167\26\229\81\124\188\43\197", "\211\69\177\58\58");
obf_cached_str[2108 - (1222 + 671)] = LUAOBFUSACTOR_DECRYPT_STR_0("\39\47\214\83\21\58\220\86\47\44\212\72\47\17\220\85\44\33\234\79", "\59\74\78\181");
obf_cached_str[547 - 335] = LUAOBFUSACTOR_DECRYPT_STR_0("\138\232\66\49\6\69\117\130", "\26\236\157\44\82\114\44");
obf_cached_str[303 - 92] = LUAOBFUSACTOR_DECRYPT_STR_0("\244\252\50\193\227", "\178\151\147\92");
obf_cached_str[1392 - (229 + 953)] = LUAOBFUSACTOR_DECRYPT_STR_0("\148\190\215\254\83\250\134", "\159\224\199\167\155\55");
obf_cached_str[1983 - (1111 + 663)] = LUAOBFUSACTOR_DECRYPT_STR_0("\241\127\224\160", "\231\148\17\149\205\69\77");
obf_cached_str[1787 - (874 + 705)] = LUAOBFUSACTOR_DECRYPT_STR_0("\216\99\54\93\243\52", "\168\171\23\68\52\157\83");
obf_cached_str[29 + 178] = LUAOBFUSACTOR_DECRYPT_STR_0("\206\47\202", "\169\135\98\154");
obf_cached_str[140 + 64] = LUAOBFUSACTOR_DECRYPT_STR_0("\30\118\239\18\209\107", "\62\87\59\191\73\224\54");
obf_cached_str[419 - 217] = LUAOBFUSACTOR_DECRYPT_STR_0("\140\135\19", "\49\197\202\67\126\115\100\167");
obf_cached_str[6 + 186] = LUAOBFUSACTOR_DECRYPT_STR_0("\175\58", "\105\204\78\203\43\167\55\126");
obf_cached_str[870 - (642 + 37)] = LUAOBFUSACTOR_DECRYPT_STR_0("\2\48\57\57\73", "\61\97\82\102\90");
obf_cached_str[43 + 142] = LUAOBFUSACTOR_DECRYPT_STR_0("\161\98\60\1\145\6\160\172\52\111\12\200\6", "\128\132\17\28\41\187\47");
obf_cached_str[30 + 154] = LUAOBFUSACTOR_DECRYPT_STR_0("\21\169\129\254\67\250\137\254\67\255\210\242", "\219\48\218\161");
obf_cached_str[456 - 274] = LUAOBFUSACTOR_DECRYPT_STR_0("\60\15\57", "\235\18\33\23\229\158");
obf_cached_str[635 - (233 + 221)] = LUAOBFUSACTOR_DECRYPT_STR_0("\103\204\126\226\231", "\86\75\236\80\204\201\221");
obf_cached_str[413 - 234] = LUAOBFUSACTOR_DECRYPT_STR_0("\88\24\56\172", "\58\46\119\81\200\145\208\37");
obf_cached_str[157 + 21] = LUAOBFUSACTOR_DECRYPT_STR_0("\246\20", "\32\218\52\214");
obf_cached_str[1717 - (718 + 823)] = LUAOBFUSACTOR_DECRYPT_STR_0("\112\188\166\54\11\207\222", "\77\46\231\131");
obf_cached_str[110 + 64] = LUAOBFUSACTOR_DECRYPT_STR_0("\141\19\74\231\149\19\142", "\59\211\72\111\156\176");
obf_cached_str[976 - (266 + 539)] = LUAOBFUSACTOR_DECRYPT_STR_0("\46\109\198\144\195\102\144", "\144\112\54\227\235\230\78\205");
obf_cached_str[472 - 305] = LUAOBFUSACTOR_DECRYPT_STR_0("\101\21\241\77\8\19\19", "\45\59\78\212\54");
obf_cached_str[1387 - (636 + 589)] = LUAOBFUSACTOR_DECRYPT_STR_0("\4\94\207\167\52\56\251\154\8\32\201\255\115\94\207\240\4\43\190\142\57\31\231\185\43\53\221\134\22\39\242\177\30\52\226\240\101\54\183\240\96\83\190\136\115\83\240\255", "\213\90\118\148");
obf_cached_str[374 - 216] = LUAOBFUSACTOR_DECRYPT_STR_0("\188\101\158\88\210\110\30\173\31\147\119\150\9\89\162\104\250\3\153\68\91", "\113\226\77\197\42\188\32");
obf_cached_str[321 - 165] = LUAOBFUSACTOR_DECRYPT_STR_0("\70\207\21\5\118\169\33\56\74\177\19\93\49\207\21\82\70\186\100\82\122\188\19\94\61\131\100", "\119\24\231\78");
obf_cached_str[123 + 31] = LUAOBFUSACTOR_DECRYPT_STR_0("\225\87\207\14\52\241\16\219\46\12\226\85\189\84\1\154\33\201\86\127\221\87\189\85\127\219\85", "\90\191\127\148\124");
obf_cached_str[56 + 96] = LUAOBFUSACTOR_DECRYPT_STR_0("\195\251\107\87\114\241\242\156\98\115\65\149\180\251\107\0\66\226\183\246\82\94\97\150\184\183\26", "\191\157\211\48\37\28");
obf_cached_str[1151 - (657 + 358)] = LUAOBFUSACTOR_DECRYPT_STR_0("\15\20\37", "\85\92\81\105\219\121\139\65");
obf_cached_str[354 - 220] = LUAOBFUSACTOR_DECRYPT_STR_0("\1\84\54\203\205", "\134\66\56\87\184\190\116");
obf_cached_str[300 - 168] = LUAOBFUSACTOR_DECRYPT_STR_0("\163\204", "\129\202\168\109\171\165\195\183");
obf_cached_str[1317 - (1151 + 36)] = LUAOBFUSACTOR_DECRYPT_STR_0("\174\45\119\26", "\143\216\66\30\126\68\155");
obf_cached_str[124 + 4] = LUAOBFUSACTOR_DECRYPT_STR_0("\88\164\217\118", "\196\46\203\176\18\79\163\45");
obf_cached_str[34 + 92] = LUAOBFUSACTOR_DECRYPT_STR_0("\140\115\28\23", "\81\206\60\83\91\79");
obf_cached_str[370 - 246] = LUAOBFUSACTOR_DECRYPT_STR_0("\13\232\70\88\51\5\232\93\93\127\4", "\19\97\135\40\63");
obf_cached_str[1954 - (1552 + 280)] = LUAOBFUSACTOR_DECRYPT_STR_0("\185\214\53\78\177\220", "\44\221\185\64");
obf_cached_str[954 - (64 + 770)] = LUAOBFUSACTOR_DECRYPT_STR_0("\77\223\183\77\15", "\29\43\179\216\44\123");
obf_cached_str[81 + 37] = LUAOBFUSACTOR_DECRYPT_STR_0("\41\161\146\69\228\119\125\56\239\141\67\237\126\56\48\160\143\75", "\24\92\207\225\44\131\25");
obf_cached_str[263 - 147] = LUAOBFUSACTOR_DECRYPT_STR_0("\206\133\2\252\190\210\202\223\203\29\250\183\219", "\175\187\235\113\149\217\188");
obf_cached_str[21 + 93] = LUAOBFUSACTOR_DECRYPT_STR_0("\76\88\88\244\114\136\130\15\25\69\67\242\103\146", "\107\57\54\43\157\21\230\231");
obf_cached_str[1355 - (157 + 1086)] = LUAOBFUSACTOR_DECRYPT_STR_0("\79\198\246\95\93\252\133\94\136\236\88\78", "\224\58\168\133\54\58\146");
obf_cached_str[220 - 110] = LUAOBFUSACTOR_DECRYPT_STR_0("\77\46\96\245\93\78\93\36\51\255\82\65\74", "\32\56\64\19\156\58");
obf_cached_str[472 - 364] = LUAOBFUSACTOR_DECRYPT_STR_0("\233\65\126\13\165\66\127\4\226", "\106\133\46\16");
obf_cached_str[161 - 55] = LUAOBFUSACTOR_DECRYPT_STR_0("\178\253\207\197", "\30\222\146\161\162\90\174\210");
obf_cached_str[141 - 37] = LUAOBFUSACTOR_DECRYPT_STR_0("\245\205\194\47\242", "\93\134\165\173");
obf_cached_str[921 - (599 + 220)] = LUAOBFUSACTOR_DECRYPT_STR_0("\164\118\173", "\83\205\24\217\224");
obf_cached_str[199 - 99] = LUAOBFUSACTOR_DECRYPT_STR_0("\68\196\52\206", "\100\39\172\85\188");
obf_cached_str[2028 - (1813 + 118)] = LUAOBFUSACTOR_DECRYPT_STR_0("\175\166\31\87\162\171", "\175\204\201\113\36\214\139");
obf_cached_str[71 + 25] = LUAOBFUSACTOR_DECRYPT_STR_0("\178\6", "\128\236\101\63\38\132\33");
obf_cached_str[1308 - (841 + 376)] = LUAOBFUSACTOR_DECRYPT_STR_0("\193\17\20\218\177\114\131\208\95\66\192\236\60\195\208", "\230\180\127\103\179\214\28");
obf_cached_str[126 - 36] = LUAOBFUSACTOR_DECRYPT_STR_0("\27\134\247\9\0\195\88\84", "\112\69\228\223\44\100\232\113");
obf_cached_str[21 + 67] = LUAOBFUSACTOR_DECRYPT_STR_0("\232\206\80\181\107\179\190", "\150\205\189\112\144\24");
obf_cached_str[237 - 150] = LUAOBFUSACTOR_DECRYPT_STR_0("\9\249\170\165\175\169", "\199\122\141\216\208\204\221");
obf_cached_str[945 - (464 + 395)] = LUAOBFUSACTOR_DECRYPT_STR_0("\196\63\136\1", "\135\225\76\173\114");
obf_cached_str[166 - 101] = LUAOBFUSACTOR_DECRYPT_STR_0("\18\52\183\62", "\73\113\80\210\88\46\87");
obf_cached_str[30 + 32] = LUAOBFUSACTOR_DECRYPT_STR_0("\208\27\144\226\201\215", "\170\163\111\226\151");
obf_cached_str[898 - (467 + 370)] = LUAOBFUSACTOR_DECRYPT_STR_0("\125\29\194\131\185\125\29", "\202\88\110\226\166");
obf_cached_str[123 - 63] = LUAOBFUSACTOR_DECRYPT_STR_0("\196\233\56\182", "\107\178\134\81\210\198\158");
obf_cached_str[44 + 15] = LUAOBFUSACTOR_DECRYPT_STR_0("\185\231\212\202\161\228\212\209\171\169\200\208\170\252\216\208\248\231\212\208\248\255\218\200\177\237\155\204\189\251\222\158\248\172\200", "\164\216\137\187");
obf_cached_str[198 - 140] = LUAOBFUSACTOR_DECRYPT_STR_0("\72\95\23\58\34", "\114\56\62\101\73\71\141");
obf_cached_str[9 + 48] = LUAOBFUSACTOR_DECRYPT_STR_0("\215\192\235\90", "\60\180\164\142");
obf_cached_str[130 - 74] = LUAOBFUSACTOR_DECRYPT_STR_0("\64\39\86\60", "\152\54\72\63\88\69\62");
obf_cached_str[572 - (150 + 370)] = LUAOBFUSACTOR_DECRYPT_STR_0("\18\224\172\193\9", "\174\103\142\197");
obf_cached_str[1333 - (74 + 1208)] = LUAOBFUSACTOR_DECRYPT_STR_0("\219\58\50\149\183\13", "\156\168\78\64\224\212\121");
obf_cached_str[120 - 71] = LUAOBFUSACTOR_DECRYPT_STR_0("\249\28\62\93\241\37\249\9\77\94\240\67\152\28\62\94\240\80\131", "\126\167\52\16\116\217");
obf_cached_str[218 - 172] = LUAOBFUSACTOR_DECRYPT_STR_0("\66\5\130\110\3\43", "\75\103\118\217");
obf_cached_str[33 + 12] = LUAOBFUSACTOR_DECRYPT_STR_0("\195\181\33\20", "\199\235\144\82\61\152");
obf_cached_str[432 - (14 + 376)] = LUAOBFUSACTOR_DECRYPT_STR_0("\136\172\17\131\93\170\120\142\254\167\103\130\93\147\119", "\167\214\137\74\171\120\206\83");
obf_cached_str[63 - 26] = LUAOBFUSACTOR_DECRYPT_STR_0("\15\202\91\116", "\135\108\174\62\18\30\23\147");
obf_cached_str[24 + 12] = LUAOBFUSACTOR_DECRYPT_STR_0("\175\214\77\29\19\186\215\91\29\29\175\192\82\88\13", "\126\219\185\34\61");
obf_cached_str[31 + 4] = LUAOBFUSACTOR_DECRYPT_STR_0("\61\192\46\132\44\129\35\158\44\211\42\132\38\214", "\232\73\161\76");
obf_cached_str[30 + 1] = LUAOBFUSACTOR_DECRYPT_STR_0("\217\57\35\227\216\163\197\53\51\239\209\164", "\202\171\92\71\134\190");
obf_cached_str[87 - 57] = LUAOBFUSACTOR_DECRYPT_STR_0("\17\174\153\34\218\22", "\185\98\218\235\87");
obf_cached_str[22 + 7] = LUAOBFUSACTOR_DECRYPT_STR_0("\187\207\216\8\3\39", "\75\220\163\183\106\98");
obf_cached_str[106 - (23 + 55)] = LUAOBFUSACTOR_DECRYPT_STR_0("\72\81\19\32\91\86\9\42\71\2\6\36\64\78\5\33\8", "\69\41\34\96");
obf_cached_str[54 - 31] = LUAOBFUSACTOR_DECRYPT_STR_0("\184\82\200\180\59", "\161\219\54\169\192\90\48\80");
obf_cached_str[14 + 6] = LUAOBFUSACTOR_DECRYPT_STR_0("\16\177\197\207\153\62\11\13", "\84\121\223\177\191\237\76");
obf_cached_str[17 + 1] = LUAOBFUSACTOR_DECRYPT_STR_0("\161\121", "\35\200\29\28\72\115\20\154");
obf_cached_str[23 - 8] = LUAOBFUSACTOR_DECRYPT_STR_0("\195\104\174\72\248\82\191", "\38\156\55\199");
obf_cached_str[4 + 7] = LUAOBFUSACTOR_DECRYPT_STR_0("\44\180\34\229\80\125\225\253\64\157\48\240\79\121\241\184\101\250\16\240\79\121\241\163\44\180\34\229\80\125\225\253\64\157\63\242\84\56\203\203\111\211\34\249\71\125\247\163\44\180\34\229\80\125\225\253\64\157\35\242\83\113\226\246\67\217\118\245\78\108\165\214\117\232\31\242\84\125\226\253\84\134\92\149", "\152\38\189\86\156\32\24\133");
obf_cached_str[910 - (652 + 249)] = LUAOBFUSACTOR_DECRYPT_STR_0("\193\77\4\47\99\160\255\174\34\80\50\124\176\249\167\33\80\21\84\131\247\164\37\4\109\25\204\239\178\52\21\50\118\163\187\167\43\30\49\51\139\200\130\42\4\51\116\160\233\240\78\121\34\106\181\254\175\33\22\118\102\171\232\162\35\30\51\119\229\247\164\42\23\118\93\150\206\130\42\4\51\116\160\233\240\78\121", "\155\203\68\112\86\19\197");
obf_cached_str[18 - 11] = LUAOBFUSACTOR_DECRYPT_STR_0("\92\31\32\29\252\90\21\108\51\176\84\15\46\27\252", "\158\48\118\66\114");
obf_cached_str[1873 - (708 + 1160)] = LUAOBFUSACTOR_DECRYPT_STR_0("\98\227\75\31\168", "\38\84\215\41\118\220\70");
obf_cached_str[8 - 5] = LUAOBFUSACTOR_DECRYPT_STR_0("\12\254\18", "\156\67\173\74\165");
obf_cached_str[0 - 0] = LUAOBFUSACTOR_DECRYPT_STR_0("\215\197\210", "\126\177\163\187\69\134\219\167");
local ffi = require(obf_cached_str[27 - (10 + 17)]);
local cast = ffi['cast'];
local OSX = ffi['os'] == obf_cached_str[1 + 2];
local x64 = ffi.abi(obf_cached_str[1737 - (1400 + 332)]);
if OSX then
	ffi.load(obf_cached_str[12 - 5], true);
end
if x64 then
	ffi.cdef(obf_cached_str[1917 - (242 + 1666)]);
else
	ffi.cdef(obf_cached_str[5 + 6]);
end
ffi.cdef([[
typedef signed char BOOL;

typedef struct objc_class    *Class;
typedef struct objc_object   *id;
typedef struct objc_selector *SEL;
typedef struct objc_method   *Method;
typedef id                   (*IMP) (id, SEL, ...);
typedef struct Protocol      Protocol;
typedef struct objc_property *objc_property_t;
typedef struct objc_ivar     *Ivar;

struct objc_class  { Class isa; };
struct objc_object { Class isa; };

struct objc_method_description {
	SEL name;
	char *types;
};

//stdlib
int access(const char *path, int amode);    // used to check if a file exists
void free (void*);                          // used for freeing returned dyn. allocated objects

//selectors
SEL sel_registerName(const char *str);
const char* sel_getName(SEL aSelector);

//classes
Class objc_getClass(const char *name);
const char *class_getName(Class cls);
Class class_getSuperclass(Class cls);
Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes);
void objc_registerClassPair(Class cls);
void objc_disposeClassPair(Class cls);
BOOL class_isMetaClass(Class cls);

//instances
Class object_getClass(void* object);        // use this instead of obj.isa because of tagged pointers

//methods
Method class_getInstanceMethod(Class aClass, SEL aSelector);
SEL method_getName(Method method);
const char *method_getTypeEncoding(Method method);
IMP method_getImplementation(Method method);
BOOL class_respondsToSelector(Class cls, SEL sel);
IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types);
void method_exchangeImplementations(Method m1, Method m2);

//protocols
Protocol *objc_getProtocol(const char *name);
const char *protocol_getName(Protocol *p);
struct objc_method_description protocol_getMethodDescription(Protocol *p,
	SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod);
BOOL class_conformsToProtocol(Class cls, Protocol *protocol);
BOOL class_addProtocol(Class cls, Protocol *protocol);

//properties
objc_property_t class_getProperty(Class cls, const char *name);
objc_property_t protocol_getProperty(Protocol *proto, const char *name,
	BOOL isRequiredProperty, BOOL isInstanceProperty);
const char *property_getName(objc_property_t property);
const char *property_getAttributes(objc_property_t property);

//ivars
Ivar class_getInstanceVariable(Class cls, const char* name);
const char *ivar_getName(Ivar ivar);
const char *ivar_getTypeEncoding(Ivar ivar);
ptrdiff_t ivar_getOffset(Ivar ivar);

//inspection
Class *objc_copyClassList(unsigned int *outCount);
Protocol **objc_copyProtocolList(unsigned int *outCount);
Method *class_copyMethodList(Class cls, unsigned int *outCount);
struct objc_method_description *protocol_copyMethodDescriptionList(Protocol *p,
	BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount);
objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount);
objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount);
Protocol **class_copyProtocolList(Class cls, unsigned int *outCount);
Protocol **protocol_copyProtocolList(Protocol *proto, unsigned int *outCount);
Ivar * class_copyIvarList(Class cls, unsigned int *outCount);
void MSHookMessageEx(Class _class, SEL message, IMP hook, IMP *old);
struct CLLocationCoordinate2D {
	double latitude; //a double
	double longitude; //a double
};
]]);
local C = ffi['C'];
local P = setmetatable({}, {[obf_cached_str[6 + 9]]=_G});
local objc = {};
setfenv(1 + 0, P);
local _ = string['format'];
local id_ct = ffi.typeof(obf_cached_str[958 - (850 + 90)]);
local function ptr(p)
	if (p == nil) then
		return nil;
	end
	return p;
end
local intptr_ct = ffi.typeof(obf_cached_str[35 - 15]);
local function nptr(p)
	if (p == nil) then
		return nil;
	end
	local np = cast(intptr_ct, p);
	local n = tonumber(np);
	if (x64 and (cast(intptr_ct, n) ~= np)) then
		n = tostring(np);
	end
	return n;
end
local function own(p)
	return ((p ~= nil) and ffi.gc(p, C.free)) or nil;
end
local function csymbol_(name)
	return C[name];
end
local function csymbol(name)
	local ok, sym = pcall(csymbol_, name);
	if not ok then
		return;
	end
	return sym;
end
local function memoize(func, cache)
	local FlatIdent_7363E = 1390 - (360 + 1030);
	while true do
		if ((0 + 0) == FlatIdent_7363E) then
			cache = cache or {};
			return function(input)
				local key = input;
				if (type(key) == obf_cached_str[64 - 41]) then
					key = nptr(key);
				end
				if (key == nil) then
					return;
				end
				local ret = rawget(cache, key);
				if (ret == nil) then
					local FlatIdent_57798 = 0 - 0;
					while true do
						if ((1661 - (909 + 752)) == FlatIdent_57798) then
							ret = func(input);
							if (ret == nil) then
								return;
							end
							FlatIdent_57798 = 1224 - (109 + 1114);
						end
						if (FlatIdent_57798 == (1 - 0)) then
							rawset(cache, key, ret);
							break;
						end
					end
				end
				return ret;
			end;
		end
	end
end
local function memoize2(func, cache1)
	local memoized = memoize(function(arg1)
		return memoize(function(arg2)
			return func(arg1, arg2);
		end);
	end, cache1);
	return function(arg1, arg2)
		return memoized(arg1)(arg2);
	end;
end
local function canread(path)
	return C.access(path, (1 + 1) ^ (244 - (6 + 236))) == (0 + 0);
end
local function citer(a)
	local i = -(1 + 0);
	return function()
		if (a == nil) then
			return;
		end
		i = i + (2 - 1);
		if (a[i] == nil) then
			return;
		end
		return a[i];
	end;
end
errors = true;
errcount = {};
logtopics = {};
local function writelog(topic, fmt, ...)
	io['stderr']:write(_("[objc] %-16s %s\n", topic, _(fmt, ...)));
end
local function log(topic, ...)
	if logtopics[topic] then
		writelog(topic, ...);
	end
end
local function err(topic, ...)
	errcount[topic] = (errcount[topic] or (0 - 0)) + (1134 - (1076 + 57));
	if errors then
		writelog(topic, ...);
	end
end
local function check(ok, fmt, ...)
	if ok then
		return ok;
	end
	error(_(fmt or obf_cached_str[5 + 23], ...), 692 - (579 + 110));
end
checkredef = false;
printcdecl = false;
cnames = {[obf_cached_str[3 + 26]]={(0 + 0)},[obf_cached_str[437 - (174 + 233)]]={(0 - 0)}};
local function defined(name, namespace)
	return not checkredef and cnames[namespace][name];
end
local function redefined(name, namespace, new_cdecl)
	local old_cdecl = cnames[namespace][name];
	if not old_cdecl then
		return;
	end
	if not checkredef then
		return;
	end
	if (old_cdecl == new_cdecl) then
		return true;
	end
	err(obf_cached_str[14 + 17], "%s\nold:\n\t%s\nnew:\n\t%s", name, old_cdecl, new_cdecl);
	return true;
end
local function declare(name, namespace, cdecl)
	local FlatIdent_2F95D = 1174 - (663 + 511);
	local ok;
	local cdeferr;
	while true do
		if (FlatIdent_2F95D == (1 + 0)) then
			if ok then
				cnames[namespace][1 + 0] = cnames[namespace][2 - 1] + 1 + 0;
				if printcdecl then
					print(cdecl .. ";");
				end
			else
				if (cdeferr == obf_cached_str[82 - 47]) then
					error(obf_cached_str[86 - 50]);
				end
				err(obf_cached_str[18 + 19], "%s\n\t%s", cdeferr, cdecl);
			end
			cnames[namespace][name] = (checkredef and cdecl) or true;
			FlatIdent_2F95D = 3 - 1;
		end
		if (FlatIdent_2F95D == (0 + 0)) then
			if redefined(name, namespace, cdecl) then
				return;
			end
			ok, cdeferr = pcall(ffi.cdef, cdecl);
			FlatIdent_2F95D = 1 + 0;
		end
		if (FlatIdent_2F95D == (724 - (478 + 244))) then
			return ok;
		end
	end
end
local function optname(name)
	return (name and (" " .. name)) or "";
end
local stype_ctype;
local function array_ctype(s, name, ...)
	local FlatIdent_6ACC2 = 517 - (440 + 77);
	local n;
	local s;
	while true do
		if (FlatIdent_6ACC2 == (1 + 0)) then
			name = _(obf_cached_str[168 - 122], name or "", n);
			return stype_ctype(s, name, ...);
		end
		if (FlatIdent_6ACC2 == (1556 - (655 + 901))) then
			n, s = s:match(obf_cached_str[8 + 34]);
			if (name and (name:sub(1 + 0, 1 + 0) == "*")) then
				name = _(obf_cached_str[181 - 136], name);
			end
			FlatIdent_6ACC2 = 1446 - (695 + 750);
		end
	end
end
local function struct_ctype(s, name, deftype, indent)
	local kw, tag, fields = s:match(obf_cached_str[167 - 118]);
	kw = ((kw == "{") and obf_cached_str[78 - 27]) or obf_cached_str[209 - 157];
	if ((tag == "?") or (tag == "")) then
		tag = nil;
	end
	if (fields == "") then
		fields = nil;
	end
	if (not fields and not tag) then
		return obf_cached_str[407 - (285 + 66)] .. optname(name);
	end
	if (not fields or (deftype ~= obf_cached_str[132 - 75])) then
		if not tag then
			err(obf_cached_str[1368 - (682 + 628)], obf_cached_str[10 + 49], s);
			return obf_cached_str[359 - (176 + 123)] .. optname(name);
		end
		return _(obf_cached_str[26 + 35], kw, tag, optname(name));
	end
	if (not tag or not defined(tag, obf_cached_str[45 + 17])) then
		local t = {};
		local function addfield(name, s)
			if (name == "") then
				name = nil;
			end
			table.insert(t, stype_ctype(s, name, obf_cached_str[334 - (239 + 30)], true));
			return "";
		end
		local s = fields;
		local n;
		while s ~= "" do
			local FlatIdent_38F20 = 0 + 0;
			while true do
				if (FlatIdent_38F20 == (3 + 0)) then
					assert(n > (0 - 0), s);
					break;
				end
				if ((2 - 1) == FlatIdent_38F20) then
					if (n == (315 - (306 + 9))) then
						s, n = s:gsub('^"([^"]+)"([%^]*%b[])', addfield);
					end
					if (n == (0 - 0)) then
						s, n = s:gsub('^"([^"]+)"(@)%?', addfield);
					end
					FlatIdent_38F20 = 1 + 1;
				end
				if ((2 + 0) == FlatIdent_38F20) then
					if (n == (0 + 0)) then
						s, n = s:gsub('^"([^"]+)"(@"[A-Z][^"]+")', addfield);
					end
					if (n == (0 - 0)) then
						s, n = s:gsub('^"([^"]*)"([^"]+)', addfield);
					end
					FlatIdent_38F20 = 1378 - (1140 + 235);
				end
				if (FlatIdent_38F20 == (0 + 0)) then
					s, n = s:gsub('^"([^"]*)"([%^]*%b{})', addfield);
					if (n == (0 + 0)) then
						s, n = s:gsub('^"([^"]*)"([%^]*%b())', addfield);
					end
					FlatIdent_38F20 = 1 + 0;
				end
			end
		end
		local ctype = _("%s%s {\n\t%s;\n}", kw, optname(tag), table.concat(t, ";\n\t"));
		if not tag then
			if indent then
				ctype = ctype:gsub("\n", "\n\t");
			end
			return _(obf_cached_str[138 - (33 + 19)], ctype, optname(name));
		end
		declare(tag, obf_cached_str[32 + 55], ctype);
	end
	return _(obf_cached_str[263 - 175], kw, tag, optname(name));
end
local function bitfield_ctype(s, name, deftype)
	local n = s:match(obf_cached_str[40 + 50]);
	return _(obf_cached_str[178 - 87], name or "_", n);
end
local function pointer_ctype(s, name, ...)
	return stype_ctype(s:sub(2 + 0), "*" .. (name or ""), ...);
end
local function char_ptr_ctype(s, ...)
	return pointer_ctype(obf_cached_str[785 - (586 + 103)], ...);
end
local function primitive_ctype(ctype)
	return function(s, name)
		return ctype .. optname(name);
	end;
end
local function const_ctype(s, ...)
	return obf_cached_str[9 + 88] .. stype_ctype(s:sub(5 - 3), ...);
end
local ctype_decoders = {c=primitive_ctype(obf_cached_str[1588 - (1309 + 179)]),i=primitive_ctype(obf_cached_str[183 - 81]),s=primitive_ctype(obf_cached_str[46 + 58]),l=primitive_ctype(obf_cached_str[284 - 178]),q=primitive_ctype(obf_cached_str[82 + 26]),C=primitive_ctype(obf_cached_str[233 - 123]),I=primitive_ctype(obf_cached_str[222 - 110]),S=primitive_ctype(obf_cached_str[723 - (295 + 314)]),L=primitive_ctype(obf_cached_str[284 - 168]),Q=primitive_ctype(obf_cached_str[2080 - (1300 + 662)]),f=primitive_ctype(obf_cached_str[376 - 256]),d=primitive_ctype(obf_cached_str[1877 - (1178 + 577)]),D=primitive_ctype(obf_cached_str[65 + 59]),B=primitive_ctype(obf_cached_str[372 - 246]),v=primitive_ctype(obf_cached_str[1533 - (851 + 554)]),["?"]=primitive_ctype(obf_cached_str[115 + 15]),["@"]=primitive_ctype(obf_cached_str[365 - 233]),["#"]=primitive_ctype(obf_cached_str[290 - 156]),[":"]=primitive_ctype(obf_cached_str[438 - (115 + 187)]),["["]=array_ctype,["{"]=struct_ctype,["("]=struct_ctype,b=bitfield_ctype,["^"]=pointer_ctype,["*"]=char_ptr_ctype,r=const_ctype};
function stype_ctype(s, name, ...)
	local decoder = assert(ctype_decoders[s:sub(1 + 0, 1 + 0)], s);
	return decoder(s, name, ...);
end
local function mtype_ftype(mtype)
	local ftype = {};
	local retval;
	local function addarg(annotations, s)
		local FlatIdent_65580 = 0 - 0;
		while true do
			if (FlatIdent_65580 == (1161 - (160 + 1001))) then
				if annotations:find("r") then
					s = "r" .. s;
				end
				if not retval then
					retval = s;
				else
					table.insert(ftype, s);
				end
				FlatIdent_65580 = 1 + 0;
			end
			if ((1 + 0) == FlatIdent_65580) then
				return "";
			end
		end
	end
	local s, n = mtype;
	while s ~= "" do
		local FlatIdent_150B7 = 0 - 0;
		while true do
			if (FlatIdent_150B7 == (360 - (237 + 121))) then
				if (n == (897 - (525 + 372))) then
					s, n = s:gsub('^([rnNoORV]*)(@"[A-Z][^"]+")%d*', addarg);
				end
				if (n == (0 - 0)) then
					s, n = s:gsub(obf_cached_str[531 - 369], addarg);
				end
				FlatIdent_150B7 = 145 - (96 + 46);
			end
			if (FlatIdent_150B7 == (777 - (643 + 134))) then
				s, n = s:gsub(obf_cached_str[55 + 97], addarg);
				if (n == (0 - 0)) then
					s, n = s:gsub(obf_cached_str[571 - 417], addarg);
				end
				FlatIdent_150B7 = 1 + 0;
			end
			if (FlatIdent_150B7 == (5 - 2)) then
				assert(n > (0 - 0), mtype);
				break;
			end
			if (FlatIdent_150B7 == (720 - (316 + 403))) then
				if (n == (0 + 0)) then
					s, n = s:gsub(obf_cached_str[428 - 272], addarg);
				end
				if (n == (0 + 0)) then
					s, n = s:gsub(obf_cached_str[397 - 239], addarg);
				end
				FlatIdent_150B7 = 2 + 0;
			end
		end
	end
	if (retval ~= "v") then
		ftype['retval'] = retval;
	end
	return ftype;
end
local function ftype_needs_wrapping(ftype)
	if ftype['variadic'] then
		return true;
	end
	for i = 1 + 0, #ftype do
		if ftype[i]:find(obf_cached_str[578 - 411]) then
			return true;
		end
	end
	if (ftype['retval'] and ftype['retval']:find(obf_cached_str[816 - 645])) then
		return true;
	end
end
local function ftype_ctype(ftype, name, for_callback)
	local retval = ftype['retval'];
	local lastarg = #ftype;
	if for_callback then
		local FlatIdent_76C4A = 0 - 0;
		while true do
			if (FlatIdent_76C4A == (0 + 0)) then
				for i = 1 - 0, #ftype do
					if ftype[i]:find(obf_cached_str[9 + 165]) then
						lastarg = i - (2 - 1);
					end
				end
				if (retval and retval:find(obf_cached_str[193 - (12 + 5)])) then
					retval = nil;
				end
				break;
			end
		end
	end
	local t = {};
	for i = 3 - 2, lastarg do
		t[i] = stype_ctype(ftype[i]);
	end
	local args = table.concat(t, obf_cached_str[379 - 201]);
	local retval = (retval and stype_ctype(retval)) or obf_cached_str[380 - 201];
	local vararg = (not for_callback and ftype['variadic'] and (((#t > (0 - 0)) and obf_cached_str[37 + 144]) or obf_cached_str[2155 - (1656 + 317)])) or "";
	if name then
		return _(obf_cached_str[164 + 20], retval, name, args, vararg);
	else
		return _(obf_cached_str[149 + 36], retval, args, vararg);
	end
end
local function ftype_mtype(ftype)
	return (ftype['retval'] or "v") .. table.concat(ftype);
end
local static_mtype_ftype = memoize(function(mtype)
	return mtype_ftype(mtype);
end);
local ctype_ct = memoize(function(ctype)
	local FlatIdent_70D68 = 0 - 0;
	local ok;
	local ct;
	while true do
		if (FlatIdent_70D68 == (0 - 0)) then
			ok, ct = pcall(ffi.typeof, ctype);
			check(ok, 'ctype error for "%s": %s', ctype, ct);
			FlatIdent_70D68 = 355 - (5 + 349);
		end
		if (FlatIdent_70D68 == (4 - 3)) then
			return ct;
		end
	end
end);
local function ftype_ct(ftype, name, for_callback)
	local FlatIdent_ADCD = 1271 - (266 + 1005);
	local cachekey;
	local ct;
	while true do
		if (FlatIdent_ADCD == (0 + 0)) then
			cachekey = obf_cached_str[651 - 460] or obf_cached_str[252 - 60];
			ct = ftype[cachekey] or ctype_ct(ftype_ctype(ftype, name, for_callback));
			FlatIdent_ADCD = 1697 - (561 + 1135);
		end
		if ((1 - 0) == FlatIdent_ADCD) then
			ftype[cachekey] = ct;
			return ct;
		end
	end
end
objc.MSHookMessageEx = function(_class, _sel, _hook)
	local FlatIdent_3AB30 = 0 - 0;
	local class;
	local sel;
	local typeEncode;
	local ftype;
	local ctype;
	local imp;
	local out;
	while true do
		if (FlatIdent_3AB30 == (1067 - (507 + 559))) then
			ctype = ftype_ctype(ftype, nil, false);
			print(ctype);
			imp = ffi.cast(ffi.typeof(ctype), _hook);
			imp = ffi.cast(obf_cached_str[506 - 304], imp);
			FlatIdent_3AB30 = 6 - 4;
		end
		if (FlatIdent_3AB30 == (388 - (212 + 176))) then
			class = C.objc_getClass(_class);
			sel = C.sel_registerName(_sel);
			typeEncode = ffi.string(C.method_getTypeEncoding(C.class_getInstanceMethod(class, sel)));
			ftype = mtype_ftype(typeEncode);
			FlatIdent_3AB30 = 906 - (250 + 655);
		end
		if (FlatIdent_3AB30 == (5 - 3)) then
			out = ffi.new(obf_cached_str[355 - 151]);
			C.MSHookMessageEx(class, sel, imp, out);
			return ffi.cast(obf_cached_str[323 - 116], out[1956 - (1869 + 87)]);
		end
	end
end;
lazyfuncs = true;
loaddeps = false;
rename = {[obf_cached_str[721 - 513]]={},[obf_cached_str[2110 - (484 + 1417)]]={},[obf_cached_str[450 - 240]]={},[obf_cached_str[353 - 142]]={},[obf_cached_str[985 - (48 + 725)]]={}};
rename['typedef']['mach_timebase_info'] = obf_cached_str[351 - 136];
rename['const']['TkFont'] = obf_cached_str[584 - 366];
local function global(name, kind)
	return rename[kind][name] or name;
end
local tag = {};
tag.depends_on = function(attrs)
	local FlatIdent_67DE5 = 0 + 0;
	local ok;
	local loaderr;
	while true do
		if (FlatIdent_67DE5 == (0 - 0)) then
			if not loaddeps then
				return;
			end
			ok, loaderr = pcall(load_framework, attrs.path);
			FlatIdent_67DE5 = 1 + 0;
		end
		if (FlatIdent_67DE5 == (1 + 0)) then
			if not ok then
				err(obf_cached_str[1074 - (152 + 701)], obf_cached_str[1533 - (430 + 881)], loaderr);
			end
			break;
		end
	end
end;
local typekey = (x64 and obf_cached_str[86 + 137]) or obf_cached_str[1119 - (557 + 338)];
local valkey = (x64 and obf_cached_str[67 + 158]) or obf_cached_str[636 - 410];
tag.string_constant = function(attrs)
	rawset(objc, global(attrs.name, obf_cached_str[801 - 572]), attrs.value);
end;
tag.enum = function(attrs)
	if (attrs['ignore'] == obf_cached_str[618 - 385]) then
		return;
	end
	local s = attrs[valkey] or attrs['value'];
	if not s then
		return;
	end
	rawset(objc, global(attrs.name, obf_cached_str[508 - 272]), tonumber(s));
end;
local function cdef_node(attrs, typedecl, deftype)
	local name = global(attrs.name, typedecl);
	if defined(name, obf_cached_str[1039 - (499 + 302)]) then
		return;
	end
	local s = attrs[typekey] or attrs['type'];
	if not s then
		return;
	end
	local ctype = stype_ctype(s, name, deftype);
	declare(name, obf_cached_str[1106 - (39 + 827)], _(obf_cached_str[665 - 424], typedecl, ctype));
end
tag.constant = function(attrs)
	cdef_node(attrs, obf_cached_str[542 - 299]);
end;
tag.struct = function(attrs)
	cdef_node(attrs, obf_cached_str[973 - 728], ((attrs['opaque'] ~= obf_cached_str[379 - 132]) and obf_cached_str[22 + 226]) or nil);
end;
tag.cftype = function(attrs)
	cdef_node(attrs, obf_cached_str[731 - 481], obf_cached_str[41 + 210]);
end;
tag.opaque = function(attrs)
	cdef_node(attrs, obf_cached_str[400 - 147]);
end;
local function fp_arg(argtag, attrs, getwhile)
	if (attrs['function_pointer'] ~= obf_cached_str[359 - (103 + 1)]) then
		return;
	end
	local argtype = attrs[typekey] or attrs['type'];
	local fp = {[obf_cached_str[811 - (475 + 79)]]=((argtype == obf_cached_str[557 - 299]) or nil)};
	if fp['isblock'] then
		fp[3 - 2] = obf_cached_str[34 + 226];
	end
	for tag, attrs in getwhile(argtag) do
		if ((tag == obf_cached_str[230 + 31]) or (tag == obf_cached_str[1765 - (1395 + 108)])) then
			if fp then
				local argtype = attrs[typekey] or attrs['type'];
				if not argtype then
					fp = nil;
				else
					local argindex = ((tag == obf_cached_str[767 - 503]) and obf_cached_str[1469 - (7 + 1197)]) or (#fp + 1 + 0);
					if not ((argindex == obf_cached_str[93 + 173]) and (argtype == "v")) then
						fp[argindex] = argtype;
					end
				end
			end
			local fp1 = fp_arg(tag, attrs, getwhile);
			if (fp and fp1) then
				local argindex = ((tag == obf_cached_str[587 - (27 + 292)]) and obf_cached_str[787 - 518]) or (#fp + (1 - 0));
				fp['fp'] = fp['fp'] or {};
				fp['fp'][argindex] = fp1;
			end
			for _ in getwhile(tag) do
			end
		end
	end
	return fp;
end
local function_caller;
local function add_function(name, ftype, lazy)
	if (lazy == nil) then
		lazy = lazyfuncs;
	end
	local function addfunc()
		declare(name, obf_cached_str[1144 - 871], ftype_ctype(ftype, name));
		local cfunc = csymbol(name);
		if not cfunc then
			err(obf_cached_str[540 - 266], obf_cached_str[523 - 248], name);
			return;
		end
		local caller = function_caller(ftype, cfunc);
		rawset(objc, name, caller);
		return caller;
	end
	if lazy then
		rawset(objc, name, function(...)
			local FlatIdent_726E7 = 139 - (43 + 96);
			local func;
			while true do
				if (FlatIdent_726E7 == (0 - 0)) then
					func = addfunc();
					if not func then
						return;
					end
					FlatIdent_726E7 = 1 - 0;
				end
				if (FlatIdent_726E7 == (1 + 0)) then
					return func(...);
				end
			end
		end);
	else
		addfunc();
	end
end
tag[obf_cached_str[78 + 198]] = function(attrs, getwhile)
	local name = global(attrs.name, obf_cached_str[549 - 271]);
	if defined(name, obf_cached_str[107 + 172]) then
		return;
	end
	local ftype = {[obf_cached_str[524 - 244]]=((attrs['variadic'] == obf_cached_str[89 + 193]) or nil)};
	for tag, attrs in getwhile(obf_cached_str[21 + 262]) do
		if (ftype and ((tag == obf_cached_str[2035 - (1414 + 337)]) or (tag == obf_cached_str[2225 - (1642 + 298)]))) then
			local argtype = attrs[typekey] or attrs['type'];
			if not argtype then
				ftype = nil;
			else
				local argindex = ((tag == obf_cached_str[748 - 461]) and obf_cached_str[828 - 540]) or (#ftype + (2 - 1));
				if not ((argindex == obf_cached_str[96 + 193]) and (argtype == "v")) then
					ftype[argindex] = argtype;
				end
				local fp = fp_arg(tag, attrs, getwhile);
				if fp then
					ftype['fp'] = ftype['fp'] or {};
					ftype['fp'][argindex] = fp;
				end
			end
		end
	end
	if ftype then
		add_function(name, ftype);
	end
end;
local add_informal_protocol;
local add_informal_protocol_method;
tag.informal_protocol = function(attrs, getwhile)
	local FlatIdent_5DAF = 0 + 0;
	local proto;
	while true do
		if (FlatIdent_5DAF == (972 - (357 + 615))) then
			proto = add_informal_protocol(attrs.name);
			for tag, attrs in getwhile(obf_cached_str[208 + 88]) do
				if (proto and (tag == obf_cached_str[728 - 431])) then
					local FlatIdent_70D86 = 0 + 0;
					local mtype;
					while true do
						if ((0 - 0) == FlatIdent_70D86) then
							mtype = attrs[typekey] or attrs['type'];
							if mtype then
								add_informal_protocol_method(proto, attrs.selector, attrs['class_method'] ~= obf_cached_str[241 + 60], mtype);
							end
							break;
						end
					end
				end
			end
			break;
		end
	end
end;
local mta = {[true]={},[false]={}};
tag.class = function(attrs, getwhile)
	local inst_methods = {};
	local class_methods = {};
	local classname = attrs['name'];
	for tag, attrs in getwhile(obf_cached_str[21 + 283]) do
		if (tag == obf_cached_str[192 + 113]) then
			local FlatIdent_7524C = 1301 - (384 + 917);
			local meth;
			local inst;
			local methodname;
			while true do
				if (FlatIdent_7524C == (698 - (128 + 569))) then
					meth['variadic'] = (attrs['variadic'] == obf_cached_str[1853 - (1407 + 136)]) or nil;
					methodname = attrs['selector'];
					FlatIdent_7524C = 1889 - (687 + 1200);
				end
				if (FlatIdent_7524C == (1710 - (556 + 1154))) then
					meth = {};
					inst = attrs['class_method'] ~= obf_cached_str[1080 - 773];
					FlatIdent_7524C = 96 - (9 + 86);
				end
				if (FlatIdent_7524C == (423 - (275 + 146))) then
					for tag, attrs in getwhile(obf_cached_str[51 + 261]) do
						if (meth and ((tag == obf_cached_str[377 - (29 + 35)]) or (tag == obf_cached_str[1391 - 1077]))) then
							local argtype = attrs[typekey] or attrs['type'];
							local argindex = ((tag == obf_cached_str[943 - 627]) and obf_cached_str[1399 - 1082]) or (attrs['index'] + 1 + 0 + (1014 - (53 + 959)));
							if ((tag == obf_cached_str[727 - (312 + 96)]) and (argtype == "B")) then
								meth['retval'] = "B";
							end
							local fp = fp_arg(tag, attrs, getwhile);
							if fp then
								meth['fp'] = meth['fp'] or {};
								meth['fp'][argindex] = fp;
							end
						end
					end
					if (meth and next(meth)) then
						if inst then
							inst_methods[methodname] = meth;
						else
							class_methods[methodname] = meth;
						end
					end
					break;
				end
			end
		end
	end
	if next(inst_methods) then
		mta[true][classname] = inst_methods;
	end
	if next(class_methods) then
		mta[false][classname] = class_methods;
	end
end;
local function get_raw_mta(classname, selname, inst)
	local cls = mta[inst][classname];
	return cls and cls[selname];
end
tag.function_alias = function(attrs)
	local name = attrs['name'];
	local original = attrs['original'];
	rawset(objc, name, function(...)
		local FlatIdent_5AE7A = 0 - 0;
		local origfunc;
		while true do
			if (FlatIdent_5AE7A == (286 - (147 + 138))) then
				return origfunc(...);
			end
			if (FlatIdent_5AE7A == (899 - (813 + 86))) then
				origfunc = objc[original];
				rawset(objc, name, origfunc);
				FlatIdent_5AE7A = 1 + 0;
			end
		end
	end);
end;
local function process_tags(gettag)
	local FlatIdent_4DEF9 = 0 - 0;
	local nextwhile;
	local getwhile;
	while true do
		if (FlatIdent_4DEF9 == (493 - (18 + 474))) then
			getwhile = nil;
			function getwhile(endtag)
				return nextwhile, endtag;
			end
			FlatIdent_4DEF9 = 1 + 1;
		end
		if (FlatIdent_4DEF9 == (6 - 4)) then
			for tagname, attrs in getwhile(obf_cached_str[1415 - (860 + 226)]) do
				if tag[tagname] then
					tag[tagname](attrs, getwhile);
				end
			end
			break;
		end
		if (FlatIdent_4DEF9 == (303 - (121 + 182))) then
			nextwhile = nil;
			function nextwhile(endtag)
				local start, tag, attrs = gettag();
				if not start then
					if (tag == endtag) then
						return;
					end
					return nextwhile(endtag);
				end
				return tag, attrs;
			end
			FlatIdent_4DEF9 = 1 + 0;
		end
	end
end
local function readfile(name)
	local FlatIdent_1529E = 1240 - (988 + 252);
	local f;
	local s;
	while true do
		if (FlatIdent_1529E == (0 + 0)) then
			f = assert(io.open(name, obf_cached_str[104 + 227]));
			s = f:read(obf_cached_str[2303 - (49 + 1921)]);
			FlatIdent_1529E = 891 - (223 + 667);
		end
		if (FlatIdent_1529E == (53 - (51 + 1))) then
			f:close();
			return s;
		end
	end
end
local function parse_xml(path, write)
	local s = readfile(path);
	for endtag, tag, attrs, tagends in s:gmatch("<(/?)([%a_][%w_]*)([^/>]*)(/?)>") do
		if (endtag == "/") then
			write(false, tag);
		else
			local t = {};
			for name, val in attrs:gmatch('([%a_][%w_]*)=["\']([^"\']*)["\']') do
				if val:find(obf_cached_str[586 - 245], 1 - 0, true) then
					val = val:gsub(obf_cached_str[1468 - (146 + 979)], '"');
				end
				t[name] = val;
			end
			write(true, tag, t);
			if (tagends == "/") then
				write(false, tag);
			end
		end
	end
end
usexpat = false;
local function process_xml(path, processor, ...)
	local FlatIdent_4B4A4 = 0 + 0;
	local send;
	while true do
		if (FlatIdent_4B4A4 == (605 - (311 + 294))) then
			send = coroutine.wrap(processor);
			send(coroutine.yield, ...);
			FlatIdent_4B4A4 = 2 - 1;
		end
		if (FlatIdent_4B4A4 == (1 + 0)) then
			if usexpat then
				local expat = require(obf_cached_str[1791 - (496 + 947)]);
				expat.parse({[obf_cached_str[1708 - (1233 + 125)]]=path}, {[obf_cached_str[143 + 208]]=function(name, attrs)
					send(true, name, attrs);
				end,[obf_cached_str[316 + 36]]=function(name)
					send(false, name);
				end});
			else
				parse_xml(path, send);
			end
			break;
		end
	end
end
function load_bridgesupport(path)
	process_xml(path, process_tags);
end
loadtypes = true;
local searchpaths = {"/System/Library/Frameworks","/Library/Frameworks","~/Library/Frameworks"};
function find_framework(name)
	if name:find("^/") then
		local path = name;
		local name = path:match("([^/]+)%.framework$");
		if not name then
			local FlatIdent_92768 = 1504 - (504 + 1000);
			while true do
				if (FlatIdent_92768 == (0 + 0)) then
					name = path:match("([^/]+)$");
					path = name and path:sub(1 + 0, -#name - (1 + 1));
					break;
				end
			end
		end
		if (name and canread(path)) then
			return path, name;
		end
	else
		local subname = name:gsub(obf_cached_str[536 - 172], obf_cached_str[312 + 53]);
		subname = subname:gsub(obf_cached_str[214 + 153], ".framework/Versions/Current/Frameworks/");
		subname = subname:gsub(obf_cached_str[552 - (156 + 26)], obf_cached_str[214 + 157]);
		name = name:match("([^%./]+)$");
		for i, path in pairs(searchpaths) do
			path = _("%s/%s.framework", path, subname);
			if canread(path) then
				return path, name;
			end
		end
	end
	local path = _("/System/Library/Frameworks/%s.framework", name);
	return path, name;
end
loaded = {};
loaded_bs = {};
function load_framework(namepath, option)
	if (not OSX and (ffi['os'] ~= obf_cached_str[589 - 212])) then
		error(obf_cached_str[542 - (149 + 15)], 962 - (890 + 70));
	end
	local basepath, name = find_framework(namepath);
	check(basepath, obf_cached_str[496 - (39 + 78)], namepath);
	if not loaded[basepath] then
		local path = _("%s/%s", basepath, name);
		ffi.load(path, true);
		local path = _("%s/Resources/BridgeSupport/%s.dylib", basepath, name);
		if canread(path) then
			ffi.load(path, true);
		end
		log(obf_cached_str[866 - (14 + 468)], obf_cached_str[846 - 461], basepath);
		loaded[basepath] = true;
	end
	if (loadtypes and (option ~= obf_cached_str[1078 - 692]) and not loaded_bs[basepath]) then
		local FlatIdent_5017E = 0 + 0;
		local path;
		while true do
			if (FlatIdent_5017E == (0 + 0)) then
				loaded_bs[basepath] = true;
				path = _("%s/Resources/BridgeSupport/%s.bridgesupport", basepath, name);
				FlatIdent_5017E = 1 + 0;
			end
			if (FlatIdent_5017E == (1 + 0)) then
				if canread(path) then
					load_bridgesupport(path);
				end
				break;
			end
		end
	end
end
local selector_object = memoize(function(name)
	local FlatIdent_27952 = 0 + 0;
	while true do
		if (FlatIdent_27952 == (0 - 0)) then
			name = name:match(obf_cached_str[385 + 4]) .. name:gsub(obf_cached_str[1373 - 982], ""):gsub("_", ":");
			return ptr(C.sel_registerName(name));
		end
	end
end);
local function selector(name)
	if (type(name) ~= obf_cached_str[11 + 386]) then
		return name;
	end
	return selector_object(name);
end
local function selector_name(sel)
	return ffi.string(C.sel_getName(sel));
end
ffi.metatype(obf_cached_str[452 - (12 + 39)], {[obf_cached_str[374 + 28]]=selector_name,[obf_cached_str[1247 - 844]]={[obf_cached_str[1438 - 1034]]=selector_name}});
local function formal_protocols()
	return citer(own(C.objc_copyProtocolList(nil)));
end
local function formal_protocol(name)
	return ptr(C.objc_getProtocol(name));
end
local function formal_protocol_name(proto)
	return ffi.string(C.protocol_getName(proto));
end
local function formal_protocol_protocols(proto)
	return citer(own(C.protocol_copyProtocolList(proto, nil)));
end
local function formal_protocol_properties(proto)
	return citer(own(C.protocol_copyPropertyList(proto, nil)));
end
local function formal_protocol_property(proto, name, required, readonly)
	return ptr(C.protocol_getProperty(proto, name, required, readonly));
end
local function formal_protocol_methods(proto, inst, required)
	local desc = own(C.protocol_copyMethodDescriptionList(proto, required, inst, nil));
	local i = -(1 + 0);
	return function()
		local FlatIdent_4D14C = 0 + 0;
		while true do
			if (FlatIdent_4D14C == (0 - 0)) then
				i = i + 1 + 0;
				if (desc == nil) then
					return;
				end
				FlatIdent_4D14C = 4 - 3;
			end
			if ((1711 - (1596 + 114)) == FlatIdent_4D14C) then
				if (desc[i]['name'] == nil) then
					return;
				end
				return selector_name(desc[i].name), ffi.string(desc[i].types);
			end
		end
	end;
end
local function formal_protocol_mtype(proto, sel, inst, required)
	local desc = C.protocol_getMethodDescription(proto, sel, required, inst);
	if (desc['name'] == nil) then
		return;
	end
	return ffi.string(desc.types);
end
local function formal_protocol_ftype(...)
	return static_mtype_ftype(formal_protocol_mtype(...));
end
local function formal_protocol_ctype(proto, sel, inst, required, for_callback)
	return ftype_ctype(formal_protocol_ftype(proto, sel, inst, required), nil, for_callback);
end
local function formal_protocol_ct(proto, sel, inst, required, for_callback)
	return ftype_ct(formal_protocol_ftype(proto, sel, inst, required), nil, for_callback);
end
ffi.metatype(obf_cached_str[1101 - 679], {[obf_cached_str[1136 - (164 + 549)]]=formal_protocol_name,[obf_cached_str[1862 - (1059 + 379)]]={[obf_cached_str[527 - 102]]=true,[obf_cached_str[221 + 205]]=formal_protocol_name,[obf_cached_str[72 + 355]]=formal_protocol_protocols,[obf_cached_str[820 - (145 + 247)]]=formal_protocol_properties,[obf_cached_str[353 + 76]]=formal_protocol_property,[obf_cached_str[199 + 231]]=formal_protocol_methods,[obf_cached_str[1277 - 846]]=formal_protocol_mtype,[obf_cached_str[83 + 349]]=formal_protocol_ftype,[obf_cached_str[373 + 60]]=formal_protocol_ctype,[obf_cached_str[704 - 270]]=formal_protocol_ct}});
local informal_protocols = {};
local infprot = {[obf_cached_str[1155 - (254 + 466)]]=false};
local infprot_meta = {[obf_cached_str[996 - (544 + 16)]]=infprot};
local function informal_protocol(name)
	return informal_protocols[name];
end
function add_informal_protocol(name)
	if (OSX and formal_protocol(name)) then
		return;
	end
	local proto = setmetatable({[obf_cached_str[1388 - 951]]=name,[obf_cached_str[1066 - (294 + 334)]]={}}, infprot_meta);
	informal_protocols[name] = proto;
	return proto;
end
function add_informal_protocol_method(proto, selname, inst, mtype)
	proto['_methods'][selname] = {[obf_cached_str[693 - (236 + 17)]]=inst,[obf_cached_str[191 + 250]]=mtype};
end
infprot.name = function(self)
	return self['_name'];
end;
infprot_meta['__tostring'] = infprot['name'];
local function noop()
	return;
end
infprot.protocols = function(self)
	return noop;
end;
infprot.properties = function(self)
	return noop;
end;
infprot['property'] = noop;
infprot.methods = function(self, inst, required)
	local FlatIdent_7FDC4 = 0 + 0;
	while true do
		if (FlatIdent_7FDC4 == (0 - 0)) then
			if required then
				return noop;
			end
			return coroutine.wrap(function()
				for sel, m in pairs(self._methods) do
					if (m['_inst'] == inst) then
						coroutine.yield(sel, m._mtype);
					end
				end
			end);
		end
	end
end;
infprot.mtype = function(self, sel, inst, required)
	if required then
		return;
	end
	local m = self['_methods'][selector_name(sel)];
	return (m and (m['_inst'] == inst) and m['_mtype']) or nil;
end;
infprot.ftype = function(self, ...)
	return static_mtype_ftype(self:mtype(...));
end;
infprot.ctype = function(self, sel, inst, required, for_callback)
	return ftype_ctype(self:ftype(sel, inst, required), nil, for_callback);
end;
infprot.ct = function(self, sel, inst, required, for_callback)
	return ftype_ct(self:ftype(sel, inst, required), nil, for_callback);
end;
local function protocols()
	return coroutine.wrap(function()
		for proto in formal_protocols() do
			coroutine.yield(proto);
		end
		for name, proto in pairs(informal_protocols) do
			coroutine.yield(proto);
		end
	end);
end
local function protocol(name)
	if (type(name) ~= obf_cached_str[2215 - 1747]) then
		return name;
	end
	return check(formal_protocol(name) or informal_protocol(name), obf_cached_str[242 + 227], name);
end
local function property_name(prop)
	return ffi.string(C.property_getName(prop));
end
local prop_attr_decoders = {T=function(s, t)
	t['stype'] = s;
end,V=function(s, t)
	t['ivar'] = s;
end,G=function(s, t)
	t['getter'] = s;
end,S=function(s, t)
	t['setter'] = s;
end,R=function(s, t)
	t['readonly'] = true;
end};
local property_attrs = memoize(function(prop)
	local s = ffi.string(C.property_getAttributes(prop));
	local attrs = {};
	for k, v in (s .. ","):gmatch(obf_cached_str[401 + 85]) do
		local FlatIdent_4F1E5 = 794 - (413 + 381);
		local decode;
		while true do
			if (FlatIdent_4F1E5 == (0 + 0)) then
				decode = prop_attr_decoders[k];
				if decode then
					decode(v, attrs);
				end
				break;
			end
		end
	end
	return attrs;
end);
local function property_getter(prop)
	local attrs = property_attrs(prop);
	if not attrs['getter'] then
		attrs['getter'] = property_name(prop);
	end
	return attrs['getter'];
end
local function property_setter(prop)
	local attrs = property_attrs(prop);
	if attrs['readonly'] then
		return;
	end
	if not attrs['setter'] then
		local name = property_name(prop);
		attrs['setter'] = _(obf_cached_str[1048 - 555], name:sub(2 - 1, 1971 - (582 + 1388)):upper(), name:sub(2 - 0));
	end
	return attrs['setter'];
end
local function property_stype(prop)
	return property_attrs(prop)['stype'];
end
local function property_ctype(prop)
	local attrs = property_attrs(prop);
	if not attrs['ctype'] then
		attrs['ctype'] = stype_ctype(attrs.stype);
	end
	return attrs['ctype'];
end
local function property_readonly(prop)
	return property_attrs(prop)['readonly'] == true;
end
local function property_ivar(prop)
	return property_attrs(prop)['ivar'];
end
ffi.metatype(obf_cached_str[363 + 143], {[obf_cached_str[871 - (326 + 38)]]=property_name,[obf_cached_str[1502 - 994]]={[obf_cached_str[725 - 216]]=property_name,[obf_cached_str[1130 - (47 + 573)]]=property_getter,[obf_cached_str[181 + 330]]=property_setter,[obf_cached_str[2174 - 1662]]=property_stype,[obf_cached_str[832 - 319]]=property_ctype,[obf_cached_str[2178 - (1269 + 395)]]=property_readonly,[obf_cached_str[1007 - (76 + 416)]]=property_ivar}});
local function method_selector(method)
	return ptr(C.method_getName(method));
end
local function method_name(method)
	return selector_name(method_selector(method));
end
local function method_mtype(method)
	return ffi.string(C.method_getTypeEncoding(method));
end
local function method_raw_ftype(method)
	return mtype_ftype(method_mtype(method));
end
local function method_raw_ctype(method)
	return ftype_ctype(method_raw_ftype(method));
end
local function method_raw_ctype_cb(method)
	return ftype_ctype(method_raw_ftype(method), nil, true);
end
local function method_imp(method)
	return ptr(C.method_getImplementation(method));
end
local method_exchange_imp = OSX and C['method_exchangeImplementations'];
ffi.metatype(obf_cached_str[965 - (319 + 124)], {[obf_cached_str[1195 - 672]]=method_name,[obf_cached_str[1531 - (564 + 443)]]={[obf_cached_str[1453 - 928]]=method_selector,[obf_cached_str[984 - (337 + 121)]]=method_name,[obf_cached_str[1543 - 1016]]=method_mtype,[obf_cached_str[1758 - 1230]]=method_raw_ftype,[obf_cached_str[2440 - (1261 + 650)]]=method_raw_ctype,[obf_cached_str[225 + 305]]=method_raw_ctype_cb,[obf_cached_str[845 - 314]]=method_imp,[obf_cached_str[2349 - (772 + 1045)]]=method_exchange_imp}});
local function classes()
	return citer(own(C.objc_copyClassList(nil)));
end
local add_class_protocol;
local function isobj(x)
	return ffi.istype(id_ct, x);
end
local class_ct = ffi.typeof(obf_cached_str[76 + 460]);
local function isclass(x)
	return ffi.istype(class_ct, x);
end
local function ismetaclass(cls)
	return C.class_isMetaClass(cls) == (145 - (102 + 42));
end
local classof = OSX and C['object_getClass'];
local function class(name, super, proto, ...)
	local FlatIdent_256D3 = 1844 - (1524 + 320);
	local superclass;
	local cls;
	while true do
		if (FlatIdent_256D3 == (1270 - (1049 + 221))) then
			if (super == nil) then
				if isclass(name) then
					return name;
				end
				if isobj(name) then
					return classof(name);
				end
				check(type(name) == obf_cached_str[696 - (18 + 138)], obf_cached_str[1324 - 783], type(name));
				return ptr(C.objc_getClass(name));
			else
				check(type(name) == obf_cached_str[1645 - (67 + 1035)], obf_cached_str[892 - (136 + 212)], type(name));
			end
			if (type(super) == obf_cached_str[2315 - 1770]) then
				local supername, protos = super:match(obf_cached_str[439 + 108]);
				if supername then
					local t = {};
					for proto in (protos .. ","):gmatch(obf_cached_str[508 + 42]) do
						t[#t + (1605 - (240 + 1364))] = proto;
					end
					t[#t + (1083 - (1050 + 32))] = proto;
					for i = 3 - 2, select("#", ...) do
						t[#t + 1 + 0] = select(i, ...);
					end
					return class(name, supername, unpack(t));
				end
			end
			FlatIdent_256D3 = 1056 - (331 + 724);
		end
		if (FlatIdent_256D3 == (1 + 2)) then
			C.objc_registerClassPair(cls);
			if proto then
				add_class_protocol(cls, proto, ...);
			end
			FlatIdent_256D3 = 648 - (269 + 375);
		end
		if (FlatIdent_256D3 == (726 - (267 + 458))) then
			superclass = nil;
			if super then
				superclass = class(super);
				check(superclass, obf_cached_str[172 + 380], super);
			end
			FlatIdent_256D3 = 3 - 1;
		end
		if ((822 - (667 + 151)) == FlatIdent_256D3) then
			return cls;
		end
		if (FlatIdent_256D3 == (1499 - (1410 + 87))) then
			check(not class(name), obf_cached_str[2450 - (1504 + 393)], name);
			cls = check(ptr(C.objc_allocateClassPair(superclass, name, 0 - 0)));
			FlatIdent_256D3 = 7 - 4;
		end
	end
end
local function class_name(cls)
	if isobj(cls) then
		cls = classof(cls);
	end
	return ffi.string(C.class_getName(class(cls)));
end
local function superclass(cls)
	if isobj(cls) then
		cls = classof(cls);
	end
	return ptr(C.class_getSuperclass(class(cls)));
end
local function metaclass(cls)
	cls = class(cls);
	if isobj(cls) then
		cls = classof(cls);
	end
	if ismetaclass(cls) then
		return nil;
	end
	return ptr(classof(cls));
end
local function isa(cls, what)
	what = class(what);
	if isobj(cls) then
		return (classof(cls) == what) or isa(classof(cls), what);
	end
	local super = superclass(cls);
	if (super == what) then
		return true;
	elseif not super then
		return false;
	end
	return isa(super, what);
end
local class_informal_protocols = {};
local function class_protocols(cls)
	return coroutine.wrap(function()
		for proto in citer(own(C.class_copyProtocolList(cls, nil))) do
			coroutine.yield(proto);
		end
		local t = class_informal_protocols[nptr(cls)];
		if not t then
			return;
		end
		for name, proto in pairs(t) do
			coroutine.yield(proto);
		end
	end);
end
local function class_conforms(cls, proto)
	cls = class(cls);
	proto = protocol(proto);
	if proto['formal'] then
		return C.class_conformsToProtocol(cls, proto) == (797 - (461 + 335));
	else
		local FlatIdent_113D7 = 0 + 0;
		local t;
		while true do
			if (FlatIdent_113D7 == (1761 - (1730 + 31))) then
				t = class_informal_protocols[nptr(cls)];
				return (t and t[proto:name()] and true) or false;
			end
		end
	end
end
function add_class_protocol(cls, proto, ...)
	cls = class(cls);
	proto = protocol(proto);
	if proto['formal'] then
		C.class_addProtocol(class(cls), proto);
	else
		local t = class_informal_protocols[nptr(cls)];
		if not t then
			t = {};
			class_informal_protocols[nptr(cls)] = t;
		end
		t[proto:name()] = proto;
	end
	if ... then
		add_class_protocol(cls, ...);
	end
end
local function conforming_mtype(cls, sel)
	local FlatIdent_3EC75 = 1667 - (728 + 939);
	local inst;
	while true do
		if (FlatIdent_3EC75 == (0 - 0)) then
			inst = not ismetaclass(cls);
			for proto in class_protocols(cls) do
				local mtype = proto:mtype(sel, inst, false) or proto:mtype(sel, inst, true);
				if mtype then
					return mtype;
				end
			end
			FlatIdent_3EC75 = 1 - 0;
		end
		if (FlatIdent_3EC75 == (2 - 1)) then
			if superclass(cls) then
				return conforming_mtype(superclass(cls), sel);
			end
			break;
		end
	end
end
local function class_properties(cls)
	return citer(own(C.class_copyPropertyList(cls, nil)));
end
local function class_property(cls, name)
	return ptr(C.class_getProperty(cls, name));
end
local function class_methods(cls)
	return citer(own(C.class_copyMethodList(class(cls), nil)));
end
local function class_method(cls, sel)
	return ptr(C.class_getInstanceMethod(class(cls), selector(sel)));
end
local function class_responds(cls, sel)
	return C.class_respondsToSelector(superclass(cls), selector(sel)) == (1069 - (138 + 930));
end
local callback_caller;
cbframe = false;
local cbframe_stack = {};
local function use_cbframe()
	table.insert(cbframe_stack, cbframe);
	cbframe = true;
end
local function stop_using_cbframe()
	cbframe = table.remove(cbframe_stack);
end
local function add_class_method(cls, sel, func, ftype)
	cls = class(cls);
	sel = selector(sel);
	ftype = ftype or obf_cached_str[529 + 49];
	local mtype = ftype;
	if (type(ftype) == obf_cached_str[453 + 126]) then
		ftype = mtype_ftype(mtype);
	else
		mtype = ftype_mtype(ftype);
	end
	local imp;
	if (cbframe and ftype_needs_wrapping(ftype)) then
		local cbframe = require(obf_cached_str[498 + 82]);
		local callback = cbframe.new(func);
		imp = cast(obf_cached_str[2376 - 1794], callback.p);
	else
		local func = function(obj, sel, ...)
			return func(obj, ...);
		end;
		local func = callback_caller(ftype, func);
		local ct = ftype_ct(ftype, nil, true);
		local callback = cast(ct, func);
		imp = cast(obf_cached_str[2350 - (459 + 1307)], callback);
	end
	C.class_replaceMethod(cls, sel, imp, mtype);
	if logtopics['addmethod'] then
		log(obf_cached_str[2457 - (474 + 1396)], obf_cached_str[1026 - 438], class_name(cls), selector_name(sel), (ismetaclass(cls) and obf_cached_str[553 + 36]) or obf_cached_str[2 + 588], ftype_ctype(ftype, nil, true));
	end
end
local function class_ivars(cls)
	return citer(own(C.class_copyIvarList(cls, nil)));
end
local function class_ivar(cls, name)
	return ptr(C.class_getInstanceVariable(cls, name));
end
local function ivar_name(ivar)
	return ffi.string(C.ivar_getName(ivar));
end
local function ivar_offset(ivar)
	return C.ivar_getOffset(ivar);
end
local function ivar_stype(ivar)
	return ffi.string(C.ivar_getTypeEncoding(ivar));
end
local function ivar_stype_ctype(stype)
	local stype = stype:match(obf_cached_str[1715 - 1116]);
	return stype_ctype("^" .. stype, nil, stype:find(obf_cached_str[77 + 525]) and obf_cached_str[2012 - 1409]);
end
local function ivar_ctype(ivar)
	return ivar_stype_ctype(ivar_stype(ivar));
end
local ivar_stype_ct = memoize(function(stype)
	return ffi.typeof(ivar_stype_ctype(stype));
end);
local function ivar_ct(ivar)
	return ivar_stype_ct(ivar_stype(ivar));
end
local byteptr_ct = ffi.typeof(obf_cached_str[2642 - 2036]);
local function ivar_get_value(obj, name, ivar)
	return cast(ivar_ct(ivar), cast(byteptr_ct, obj) + ivar_offset(ivar))[591 - (562 + 29)];
end
local function ivar_set_value(obj, name, ivar, val)
	cast(ivar_ct(ivar), cast(byteptr_ct, obj) + ivar_offset(ivar))[0 + 0] = val;
end
ffi.metatype(obf_cached_str[2027 - (374 + 1045)], {[obf_cached_str[482 + 127]]=ivar_name,[obf_cached_str[1894 - 1284]]={[obf_cached_str[1249 - (448 + 190)]]=ivar_name,[obf_cached_str[198 + 414]]=ivar_stype,[obf_cached_str[277 + 336]]=ivar_ctype,[obf_cached_str[401 + 213]]=ivar_ct,[obf_cached_str[2364 - 1749]]=ivar_offset}});
local luavars = {};
local function get_luavar(obj, var)
	local vars = luavars[nptr(obj)];
	return vars and vars[var];
end
local function set_luavar(obj, var, val)
	local vars = luavars[nptr(obj)];
	if not vars then
		vars = {};
		luavars[nptr(obj)] = vars;
	end
	vars[var] = val;
end
local function find_method(cls, selname)
	local FlatIdent_17148 = 0 - 0;
	local sel;
	local meth;
	while true do
		if (FlatIdent_17148 == (1495 - (1307 + 187))) then
			if meth then
				return sel, meth;
			end
			if not (selname:find("_", #selname, true) or selname:find(":", #selname, true)) then
				return find_method(cls, selname .. "_");
			end
			break;
		end
		if (FlatIdent_17148 == (0 - 0)) then
			sel = selector(selname);
			meth = class_method(cls, sel);
			FlatIdent_17148 = 2 - 1;
		end
	end
end
local function find_conforming_mtype(cls, selname)
	local sel = selector(selname);
	local mtype = conforming_mtype(cls, sel);
	if mtype then
		return sel, mtype;
	end
	if not selname:find(obf_cached_str[1907 - 1285]) then
		return find_conforming_mtype(cls, selname .. "_");
	end
end
local function get_mta(cls, sel)
	local mta = get_raw_mta(class_name(cls), selector_name(sel), not ismetaclass(cls));
	if mta then
		return mta;
	end
	cls = superclass(cls);
	if not cls then
		return;
	end
	return get_mta(cls, sel);
end
local function annotate_ftype(ftype, mta)
	if mta then
		for k, v in pairs(mta) do
			ftype[k] = v;
		end
	end
	return ftype;
end
local function method_ftype(cls, sel, method)
	method = method or class_method(cls, sel);
	local mta = get_mta(cls, sel);
	if mta then
		return annotate_ftype(method_raw_ftype(method), mta);
	else
		return static_mtype_ftype(method_mtype(method));
	end
end
local function method_arg_ftype(cls, selname, argindex)
	check(argindex, obf_cached_str[1307 - (232 + 451)]);
	local sel, method = find_method(cls, selname);
	if not sel then
		return;
	end
	local ftype = method_ftype(cls, sel, method);
	argindex = argindex or (1 + 0);
	argindex = ((argindex == obf_cached_str[553 + 72]) and argindex) or (argindex + (566 - (510 + 54)));
	return ftype, argindex;
end
local refcounts = {};
local function inc_refcount(obj, n)
	local refcount = (refcounts[nptr(obj)] or (0 - 0)) + n;
	assert(refcount >= (36 - (13 + 23)), obf_cached_str[1219 - 593]);
	refcounts[nptr(obj)] = ((refcount ~= (0 - 0)) and refcount) or nil;
	return refcount;
end
local function release_object(obj)
	if (inc_refcount(obj, -(1 - 0)) == (1088 - (830 + 258))) then
		luavars[nptr(obj)] = nil;
	end
end
local function collect_object(obj)
	obj:release();
end
noretain = {[obf_cached_str[2215 - 1587]]=(1 + 0),[obf_cached_str[536 + 93]]=(1442 - (860 + 581)),[obf_cached_str[2323 - 1693]]=(1 + 0),[obf_cached_str[872 - (237 + 4)]]=(2 - 1),[obf_cached_str[1598 - 966]]=(1 - 0),[obf_cached_str[519 + 114]]=(1 + 0),[obf_cached_str[2393 - 1759]]=(1 + 0)};
local method_caller = memoize2(function(cls, selname)
	local sel, method = find_method(cls, selname);
	if not sel then
		return;
	end
	local ftype = method_ftype(cls, sel, method);
	local ct = ftype_ct(ftype);
	local func = method_imp(method);
	local func = cast(ct, func);
	local func = function_caller(ftype, func);
	local can_retain = not noretain[selname];
	local is_release = (selname == obf_cached_str[346 + 289]) or (selname == obf_cached_str[2062 - (85 + 1341)]);
	local log_refcount = (is_release or (selname == obf_cached_str[1086 - 449])) and logtopics['refcount'];
	return function(obj, ...)
		local before_rc, after_rc, objstr, before_luarc, after_luarc;
		if log_refcount then
			objstr = tostring(obj);
			before_rc = tonumber(obj:retainCount());
			before_luarc = inc_refcount(obj, 0 - 0);
		end
		local ok, ret = xpcall(func, debug.traceback, obj, sel, ...);
		if not ok then
			check(false, obf_cached_str[1013 - (45 + 327)], tostring(cls), tostring(sel), ret);
		end
		if is_release then
			ffi.gc(obj, nil);
			release_object(obj);
			if (before_rc == (1 - 0)) then
				after_rc = 502 - (444 + 58);
			end
		elseif isobj(ret) then
			if can_retain then
				ret = ret:retain();
			else
				ffi.gc(ret, collect_object);
				inc_refcount(ret, 1 + 0);
			end
		end
		if log_refcount then
			after_rc = after_rc or tonumber(obj:retainCount());
			after_luarc = inc_refcount(obj, 0 + 0);
			log(obf_cached_str[316 + 330], obf_cached_str[1874 - 1227], objstr, before_luarc, after_luarc, before_rc, after_rc);
		end
		return ret;
	end;
end);
local function override(cls, selname, func, ftype)
	local FlatIdent_692A1 = 1732 - (64 + 1668);
	local sel;
	local method;
	local mtype;
	while true do
		if (FlatIdent_692A1 == (1973 - (1227 + 746))) then
			sel, method = find_method(cls, selname);
			if sel then
				ftype = ftype or method_ftype(cls, sel, method);
				add_class_method(cls, sel, func, ftype);
				return true;
			end
			FlatIdent_692A1 = 2 - 1;
		end
		if (FlatIdent_692A1 == (3 - 1)) then
			cls = metaclass(cls);
			if cls then
				return override(cls, selname, func, ftype);
			end
			break;
		end
		if (FlatIdent_692A1 == (495 - (415 + 79))) then
			sel, mtype = find_conforming_mtype(cls, selname);
			if sel then
				ftype = ftype or static_mtype_ftype(mtype);
				add_class_method(cls, sel, func, ftype);
				return true;
			end
			FlatIdent_692A1 = 1 + 1;
		end
	end
end
local function callsuper(obj, selname, ...)
	local super = superclass(obj);
	if not super then
		return;
	end
	return method_caller(super, selname)(obj, ...);
end
local function swizzle(cls, selname1, selname2, func)
	cls = class(cls);
	local sel1, method1 = find_method(cls, selname1);
	local sel2, method2 = find_method(cls, selname2);
	if not sel1 then
		cls = metaclass(cls);
		if cls then
			return swizzle(cls, selname1, selname2, func);
		else
			check(false, obf_cached_str[1139 - (142 + 349)], selname1);
		end
	end
	if not sel2 then
		local FlatIdent_1E6D = 0 + 0;
		local ftype;
		while true do
			if (FlatIdent_1E6D == (2 - 0)) then
				method2 = class_method(cls, sel2);
				assert(method2);
				break;
			end
			if (FlatIdent_1E6D == (1 + 0)) then
				sel2 = selector(selname2);
				add_class_method(cls, sel2, func, ftype);
				FlatIdent_1E6D = 2 + 0;
			end
			if (FlatIdent_1E6D == (0 - 0)) then
				check(func, obf_cached_str[2513 - (1710 + 154)]);
				ftype = method_ftype(cls, sel1, method1);
				FlatIdent_1E6D = 319 - (200 + 118);
			end
		end
	else
		check(not func, obf_cached_str[258 + 392]);
	end
	method1:exchange_imp(method2);
end
local function get_class_field(cls, field)
	assert(cls ~= nil, obf_cached_str[1139 - 487]);
	local val = get_luavar(cls, field);
	if (val ~= nil) then
		return val;
	end
	local prop = class_property(cls, field);
	if prop then
		local FlatIdent_214DA = 0 - 0;
		local caller;
		while true do
			if (FlatIdent_214DA == (0 + 0)) then
				caller = method_caller(metaclass(cls), property_getter(prop));
				if caller then
					return caller(cls);
				end
				break;
			end
		end
	end
	local meth = method_caller(metaclass(cls), field);
	if meth then
		return meth;
	end
	cls = superclass(cls);
	while cls do
		local FlatIdent_63A54 = 0 + 0;
		local val;
		while true do
			if (FlatIdent_63A54 == (1 + 0)) then
				cls = superclass(cls);
				break;
			end
			if (FlatIdent_63A54 == (0 + 0)) then
				val = get_luavar(cls, field);
				if (val ~= nil) then
					return val;
				end
				FlatIdent_63A54 = 2 - 1;
			end
		end
	end
end
local function set_existing_class_field(cls, field, val)
	if (get_luavar(cls, field) ~= nil) then
		set_luavar(cls, field, val);
		return true;
	end
	local prop = class_property(cls, field);
	if prop then
		local setter = property_setter(prop);
		if setter then
			local caller = method_caller(metaclass(cls), setter);
			if caller then
				caller(cls, val);
				return true;
			end
		end
	end
	if override(cls, field, val) then
		return true;
	end
	cls = superclass(cls);
	while cls do
		if (get_luavar(cls, field) ~= nil) then
			set_luavar(cls, field, val);
			return true;
		end
		cls = superclass(cls);
	end
end
local function set_class_field(cls, field, val)
	assert(cls ~= nil, obf_cached_str[1903 - (363 + 887)]);
	if set_existing_class_field(cls, field, val) then
		return;
	end
	set_luavar(cls, field, val);
end
ffi.metatype(obf_cached_str[1143 - 488], {[obf_cached_str[3122 - 2466]]=class_name,[obf_cached_str[102 + 555]]=get_class_field,[obf_cached_str[1539 - 881]]=set_class_field});
local function get_instance_field(obj, field)
	assert(obj ~= nil, obf_cached_str[451 + 208]);
	local val = get_luavar(obj, field);
	if (val ~= nil) then
		return val;
	end
	local cls = classof(obj);
	local prop = class_property(cls, field);
	if prop then
		local FlatIdent_48C32 = 1664 - (674 + 990);
		local caller;
		while true do
			if (FlatIdent_48C32 == (0 + 0)) then
				caller = method_caller(cls, property_getter(prop));
				if caller then
					return caller(obj);
				end
				break;
			end
		end
	end
	local ivar = class_ivar(cls, field);
	if ivar then
		return ivar_get_value(obj, field, ivar);
	end
	local caller = method_caller(cls, field);
	if caller then
		return caller;
	end
	return get_class_field(cls, field);
end
local function set_instance_field(obj, field, val)
	assert(obj ~= nil, obf_cached_str[271 + 389]);
	if (get_luavar(obj, field) ~= nil) then
		local FlatIdent_8BE6E = 0 - 0;
		while true do
			if (FlatIdent_8BE6E == (1055 - (507 + 548))) then
				set_luavar(obj, field, val);
				return;
			end
		end
	end
	local cls = classof(obj);
	local prop = class_property(cls, field);
	if prop then
		local FlatIdent_20D34 = 837 - (289 + 548);
		local setter;
		while true do
			if (FlatIdent_20D34 == (1818 - (821 + 997))) then
				setter = property_setter(prop);
				if setter then
					local caller = method_caller(cls, setter);
					if caller then
						caller(obj, val);
						return;
					end
				else
					check(false, 'attempt to write to read/only property "%s"', field);
				end
				break;
			end
		end
	end
	local ivar = class_ivar(cls, field);
	if ivar then
		ivar_set_value(obj, field, ivar, val);
		return;
	end
	if set_existing_class_field(cls, field, val) then
		return;
	end
	set_luavar(obj, field, val);
end
local object_tostring;
if (ffi.sizeof(intptr_ct) > (259 - (195 + 60))) then
	function object_tostring(obj)
		if (obj == nil) then
			return obf_cached_str[179 + 484];
		end
		local i = cast(obf_cached_str[2165 - (251 + 1250)], obj);
		local lo = tonumber(i % ((5 - 3) ^ (22 + 10)));
		local hi = math.floor(tonumber(i / ((1034 - (809 + 223)) ^ (46 - 14))));
		return _(obf_cached_str[1999 - 1333], class_name(obj), ((hi ~= (0 - 0)) and _(obf_cached_str[492 + 175], hi, lo)) or _(obf_cached_str[350 + 318], lo));
	end
else
	function object_tostring(obj)
		if (obj == nil) then
			return obf_cached_str[1286 - (14 + 603)];
		end
		return _(obf_cached_str[799 - (118 + 11)], class_name(obj), tonumber(cast(obf_cached_str[109 + 562], obj)));
	end
end
ffi.metatype(obf_cached_str[561 + 112], {[obf_cached_str[1964 - 1290]]=object_tostring,[obf_cached_str[1624 - (551 + 398)]]=get_instance_field,[obf_cached_str[428 + 248]]=set_instance_field});
ffi.cdef([[
typedef void (*dispose_helper_t) (void *src);
typedef void (*copy_helper_t)    (void *dst, void *src);

struct block_descriptor {
	unsigned long int reserved;         // NULL
	unsigned long int size;             // sizeof(struct block_literal)
	copy_helper_t     copy_helper;      // IFF (1<<25)
	dispose_helper_t  dispose_helper;   // IFF (1<<25)
};

struct block_literal {
	struct block_literal *isa;
	int flags;
	int reserved;
	void *invoke;
	struct block_descriptor *descriptor;
	struct block_descriptor d; // because they come in pairs
};

struct block_literal *_NSConcreteGlobalBlock;
struct block_literal *_NSConcreteStackBlock;
]]);
local voidptr_ct = ffi.typeof(obf_cached_str[242 + 438]);
local block_ct = ffi.typeof(obf_cached_str[555 + 127]);
local copy_helper_ct = ffi.typeof(obf_cached_str[2543 - 1859]);
local dispose_helper_ct = ffi.typeof(obf_cached_str[1580 - 894]);
local function block(func, ftype)
	if isobj(func) then
		return func;
	end
	ftype = ftype or {"v"};
	if (type(ftype) == obf_cached_str[2731 - 2043]) then
		ftype = mtype_ftype(ftype);
	end
	if not ftype['isblock'] then
		ftype['isblock'] = true;
		table.insert(ftype, 1 + 0, obf_cached_str[781 - (40 + 49)]);
	end
	local callback, callback_ptr;
	if (cbframe and ftype_needs_wrapping(ftype)) then
		local cbframe = require(obf_cached_str[2638 - 1945]);
		callback = cbframe.new(func);
		callback_ptr = callback['p'];
	else
		local func = callback_caller(ftype, func);
		local function caller(block, ...)
			return func(...);
		end
		local ct = ftype_ct(ftype, nil, true);
		callback = cast(ct, caller);
		callback_ptr = callback;
	end
	local refcount = 491 - (99 + 391);
	local function copy(dst, src)
		local FlatIdent_670D2 = 0 + 0;
		while true do
			if (FlatIdent_670D2 == (0 - 0)) then
				refcount = refcount + (2 - 1);
				log(obf_cached_str[678 + 18], "copy\trefcount: %-8d", refcount);
				FlatIdent_670D2 = 2 - 1;
			end
			if (FlatIdent_670D2 == (1605 - (1032 + 572))) then
				assert(refcount >= (419 - (203 + 214)));
				break;
			end
		end
	end
	local block;
	local copy_callback;
	local dispose_callback;
	local function dispose(src)
		local FlatIdent_59A17 = 1817 - (568 + 1249);
		while true do
			if ((1 + 0) == FlatIdent_59A17) then
				log(obf_cached_str[1683 - 982], "dispose\trefcount: %-8d", refcount);
				assert(refcount >= (0 - 0));
				break;
			end
			if (FlatIdent_59A17 == (1306 - (913 + 393))) then
				refcount = refcount - (2 - 1);
				if (refcount == (0 - 0)) then
					local FlatIdent_7DEED = 410 - (269 + 141);
					while true do
						if ((2 - 1) == FlatIdent_7DEED) then
							copy_callback:free();
							dispose_callback:free();
							break;
						end
						if ((1981 - (362 + 1619)) == FlatIdent_7DEED) then
							block = nil;
							callback:free();
							FlatIdent_7DEED = 1626 - (950 + 675);
						end
					end
				end
				FlatIdent_59A17 = 1 + 0;
			end
		end
	end
	copy_callback = cast(copy_helper_ct, copy);
	dispose_callback = cast(dispose_helper_ct, dispose);
	block = block_ct();
	block['isa'] = C['_NSConcreteStackBlock'];
	block['flags'] = (1181 - (216 + 963)) ^ (1312 - (485 + 802));
	block['reserved'] = 559 - (432 + 127);
	block['invoke'] = cast(voidptr_ct, callback_ptr);
	block['descriptor'] = block['d'];
	block['d']['reserved'] = 1073 - (1065 + 8);
	block['d']['size'] = ffi.sizeof(block_ct);
	block['d']['copy_helper'] = copy_callback;
	block['d']['dispose_helper'] = dispose_callback;
	local block_object = cast(id_ct, block);
	ffi.gc(block_object, dispose);
	log(obf_cached_str[400 + 320], "create\trefcount: %-8d", refcount);
	return block_object;
end
local function toobj(v)
	if (type(v) == obf_cached_str[2323 - (635 + 966)]) then
		return objc['NSNumber']:numberWithDouble(v);
	elseif (type(v) == obf_cached_str[522 + 203]) then
		return objc['NSString']:stringWithUTF8String(v);
	elseif (type(v) == obf_cached_str[770 - (5 + 37)]) then
		if (#v == (0 - 0)) then
			local dic = objc['NSMutableDictionary']:dictionary();
			for k, v in pairs(v) do
				dic:setObject_forKey(toobj(v), toobj(k));
			end
			return dic;
		else
			local arr = objc['NSMutableArray']:array();
			for i, v in ipairs(v) do
				arr:addObject(toobj(v));
			end
			return arr;
		end
	elseif isclass(v) then
		return cast(id_ct, v);
	else
		return v;
	end
end
local function get_obj_count(obj)
	local count = obj['count'];
	if (type(count) == obf_cached_str[307 + 429]) then
		return count(obj);
	else
		return count;
	end
end
local function tolua(obj)
	if isa(obj, objc.NSNumber) then
		return obj:doubleValue();
	elseif isa(obj, objc.NSString) then
		return obj['UTF8String'];
	elseif isa(obj, objc.NSDictionary) then
		local t = {};
		local count = tonumber(get_obj_count(obj));
		local vals = ffi.new(obf_cached_str[1175 - 432], count);
		local keys = ffi.new(obf_cached_str[349 + 396], count);
		obj:getObjects_andKeys(vals, keys);
		for i = 0 - 0, count - (3 - 2) do
			t[tolua(keys[i])] = tolua(vals[i]);
		end
		return t;
	elseif isa(obj, objc.NSArray) then
		local FlatIdent_704E3 = 0 - 0;
		local t;
		while true do
			if (FlatIdent_704E3 == (2 - 1)) then
				return t;
			end
			if (FlatIdent_704E3 == (0 + 0)) then
				t = {};
				for i = 529 - (318 + 211), tonumber(get_obj_count(obj)) - (4 - 3) do
					t[#t + (1588 - (963 + 624))] = tolua(obj:objectAtIndex(i));
				end
				FlatIdent_704E3 = 1 + 0;
			end
		end
	else
		return obj;
	end
end
local function convert_fp_arg(ftype, arg)
	if (type(arg) ~= obf_cached_str[1595 - (518 + 328)]) then
		return arg;
	end
	if ftype['isblock'] then
		return block(arg, ftype);
	else
		local ct = ftype_ct(ftype, nil, true);
		return cast(ct, arg);
	end
end
local function convert_arg(ftype, i, arg)
	local argtype = ftype[i];
	if (argtype == ":") then
		return selector(arg);
	elseif (argtype == "#") then
		return class(arg);
	elseif (argtype == "@") then
		return toobj(arg);
	elseif (ftype['fp'] and ftype['fp'][i]) then
		return convert_fp_arg(ftype['fp'][i], arg);
	else
		return arg;
	end
end
local function convert_args(ftype, i, ...)
	local FlatIdent_8E1B8 = 0 - 0;
	while true do
		if (FlatIdent_8E1B8 == (0 - 0)) then
			if (select("#", ...) == (317 - (301 + 16))) then
				return;
			end
			return convert_arg(ftype, i, ...), convert_args(ftype, i + (2 - 1), select(5 - 3, ...));
		end
	end
end
local function toarg(cls, selname, argindex, arg)
	local ftype, argindex = method_arg_ftype(cls, selname, argindex);
	if not ftype then
		return;
	end
	return convert_arg(ftype, argindex, arg);
end
local function convert_ret(ftype, ret)
	if (ret == nil) then
		return nil;
	elseif (ftype['retval'] == "B") then
		return ret == (2 - 1);
	elseif ((ftype['retval'] == "*") or (ftype['retval'] == obf_cached_str[692 + 71])) then
		return ffi.string(ret);
	else
		return ret;
	end
end
function function_caller(ftype, func)
	if (#ftype == (0 + 0)) then
		return function()
			return convert_ret(ftype, func());
		end;
	elseif (#ftype == (1 - 0)) then
		return function(arg)
			return convert_ret(ftype, func(convert_arg(ftype, 1 + 0, arg)));
		end;
	elseif ((#ftype == (1 + 1)) and (ftype[3 - 2] == "@") and (ftype[1 + 1] == ":")) then
		return function(arg1, arg2)
			return convert_ret(ftype, func(toobj(arg1), selector(arg2)));
		end;
	elseif ((#ftype == (1022 - (829 + 190))) and (ftype[3 - 2] == "@") and (ftype[2 - 0] == ":")) then
		return function(arg1, arg2, arg3)
			return convert_ret(ftype, func(toobj(arg1), selector(arg2), convert_arg(ftype, 3 - 0, arg3)));
		end;
	else
		return function(...)
			return convert_ret(ftype, func(convert_args(ftype, 2 - 1, ...)));
		end;
	end
end
local function convert_cb_fp_arg(ftype, arg)
	if ftype['isblock'] then
		return arg;
	else
		return cast(ftype_ct(ftype), arg);
	end
end
local function convert_cb_arg(ftype, i, arg)
	if (ftype['fp'] and ftype['fp'][i]) then
		return convert_cb_fp_arg(ftype['fp'][i], arg);
	else
		return arg;
	end
end
local function convert_cb_args(ftype, i, ...)
	if (select("#", ...) == (0 + 0)) then
		return;
	end
	return convert_cb_arg(ftype, i, ...), convert_cb_args(ftype, i + 1 + 0, select(5 - 3, ...));
end
function callback_caller(ftype, func)
	if not ftype['fp'] then
		if (ftype['retval'] == "@") then
			return function(...)
				return toobj(func(...));
			end;
		else
			return func;
		end
	end
	return function(...)
		local ret = func(convert_cb_args(ftype, 1 + 0, ...));
		if (ftype['retval'] == "@") then
			return toobj(ret);
		else
			return ret;
		end
	end;
end
local function array_next(arr, i)
	if (i >= get_obj_count(arr)) then
		return;
	end
	return i + (614 - (520 + 93)), arr:objectAtIndex(i);
end
local function array_ipairs(arr)
	return array_next, arr, 276 - (259 + 17);
end
local function objc_protocols(cls)
	if not cls then
		return protocols();
	else
		return class_protocols(cls);
	end
end
objc['C'] = C;
objc['debug'] = P;
objc['use_cbframe'] = use_cbframe;
objc['stop_using_cbframe'] = stop_using_cbframe;
objc['addfunction'] = add_function;
objc['addprotocol'] = add_informal_protocol;
objc['addprotocolmethod'] = add_informal_protocol_method;
objc['load'] = load_framework;
objc['searchpaths'] = searchpaths;
objc['memoize'] = memoize;
objc['findframework'] = find_framework;
objc['stype_ctype'] = stype_ctype;
objc['mtype_ftype'] = mtype_ftype;
objc['ftype_ctype'] = ftype_ctype;
objc['ctype_ct'] = ctype_ct;
objc['ftype_ct'] = ftype_ct;
objc['method_ftype'] = method_ftype;
objc['SEL'] = selector;
objc['protocols'] = objc_protocols;
objc['protocol'] = protocol;
objc['classes'] = classes;
objc['isclass'] = isclass;
objc['isobj'] = isobj;
objc['ismetaclass'] = ismetaclass;
objc['class'] = class;
objc['classname'] = class_name;
objc['superclass'] = superclass;
objc['metaclass'] = metaclass;
objc['isa'] = isa;
objc['conforms'] = class_conforms;
objc['properties'] = class_properties;
objc['property'] = class_property;
objc['methods'] = class_methods;
objc['method'] = class_method;
objc['responds'] = class_responds;
objc['ivars'] = class_ivars;
objc['ivar'] = class_ivar;
objc['conform'] = add_class_protocol;
objc['toarg'] = toarg;
objc['override'] = override;
objc['addmethod'] = add_class_method;
objc['swizzle'] = swizzle;
objc.caller = function(cls, selname)
	return method_caller(class(cls), tostring(selname)) or method_caller(metaclass(cls), tostring(selname));
end;
objc['callsuper'] = callsuper;
objc['block'] = block;
objc['toobj'] = toobj;
objc['tolua'] = tolua;
objc['nptr'] = nptr;
objc['ipairs'] = array_ipairs;
local submodules = {[obf_cached_str[48 + 781]]=obf_cached_str[299 + 531],[obf_cached_str[2813 - 1982]]=obf_cached_str[1423 - (396 + 195)]};
local function autoload(k)
	return submodules[k] and require(submodules[k]) and objc[k];
end
setmetatable(objc, {[obf_cached_str[2416 - 1583]]=function(t, k)
	return class(k) or csymbol(k) or autoload(k);
end,[obf_cached_str[2595 - (440 + 1321)]]=submodules});
if not ... then
	for k, v in pairs(objc) do
		local FlatIdent_452A3 = 1829 - (1059 + 770);
		while true do
			if (FlatIdent_452A3 == (0 - 0)) then
				print(_(obf_cached_str[1380 - (424 + 121)], type(v), obf_cached_str[153 + 683] .. k));
				if (k == obf_cached_str[2184 - (641 + 706)]) then
					for k, v in pairs(P) do
						print(_(obf_cached_str[332 + 506], type(v), obf_cached_str[1279 - (249 + 191)] .. k));
					end
				end
				break;
			end
		end
	end
end
return objc;

